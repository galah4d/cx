package gui

import "app"
import "fps"
import "gl"
import "glfw"
import "gltext"
import "gfx"
import "mat"

//-----------------------------------------------------------------------------
// Globals ...
//-----------------------------------------------------------------------------
var g_opaqueVertexColoredLines      gfx.MeshId
var g_opaqueVertexColoredTriangles  gfx.MeshId
var g_alphaVertexColoredLines       gfx.MeshId
var g_alphaVertexColoredTriangles   gfx.MeshId
var g_fullscreenQuad                gfx.MeshId

var g_skycoinTexture gfx.Texture
var g_skycoinAnim animation_id

//var g_USTexture gfx.Texture
//var g_USAnim animation_id

//var g_JPTexture gfx.Texture
//var g_JPAnim animation_id

//var g_BRTexture gfx.Texture
//var g_BRAnim animation_id

var g_pumpcxTexture_0 gfx.Texture
var g_pumpcxTexture_1 gfx.Texture

var g_pumpcxAnim animation_id
var g_dumpcxAnim animation_id

var g_depthStencilBuffer i32 = -1

var g_width i32 // ##0 handle resize events
var g_height i32 // ##0 handle resize events

//-----------------------------------------------------------------------------
// Constants ...
//-----------------------------------------------------------------------------
var GUI_INVALID     i32 =  0
var GUI_CONTROL     i32 =  1
var GUI_SCREEN      i32 =  2
var GUI_PICTURE     i32 =  3
var GUI_LABEL       i32 =  4
var GUI_PARTITION   i32 =  5
var GUI_KEYBOARD    i32 =  6
var GUI_WINDOW      i32 =  7
var GUI_GRAPH       i32 =  8
var GUI_SPLITTER    i32 =  9
var GUI_LIST        i32 = 10
var GUI_SCROLLER    i32 = 11
var GUI_LIFTER      i32 = 12
var GUI_BINDER      i32 = 13
var GUI_VECTOR      i32 = 14
var GUI_COMBO       i32 = 15

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var STATE_CLOSED    i32 = 0
var STATE_SHOWING   i32 = 1
var STATE_OPENED    i32 = 2
var STATE_CLOSING   i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DOCK_NONE       i32 = 0
var DOCK_LEFT       i32 = 1
var DOCK_RIGHT      i32 = 2
var DOCK_TOP        i32 = 3
var DOCK_BOTTOM     i32 = 4
var DOCK_FILL       i32 = 5

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DIALOG_NONE      i32 = 0
var DIALOG_OK        i32 = 1
var DIALOG_OK_CANCEL i32 = 2
var DIALOG_YES_NO    i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var ALIGN_NONE          i32 =  0
var ALIGN_LEFT          i32 =  1
var ALIGN_RIGHT         i32 =  2
var ALIGN_HORZ          i32 =  3
var ALIGN_BOTTOM        i32 =  4
var ALIGN_LEFT_BOTTOM   i32 =  5
var ALIGN_RIGHT_BOTTOM  i32 =  6
var ALIGN_HORZ_BOTTOM   i32 =  7
var ALIGN_TOP           i32 =  8
var ALIGN_LEFT_TOP      i32 =  9
var ALIGN_RIGHT_TOP     i32 = 10
var ALIGN_HORZ_TOP      i32 = 11
var ALIGN_VERT          i32 = 12
var ALIGN_VERT_LEFT     i32 = 13
var ALIGN_VERT_RIGHT    i32 = 14
var ALIGN_CENTER        i32 = 15

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSIZE_NONE   i32 = 0
var AUTOSIZE_X      i32 = 1
var AUTOSIZE_Y      i32 = 2
var AUTOSIZE        i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTORATIO_NONE  i32 = 0
var AUTORATIO_X     i32 = 1
var AUTORATIO_Y     i32 = 2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSCALE_NONE  i32 = 0
var AUTOSCALE_X     i32 = 1
var AUTOSCALE_Y     i32 = 2
var AUTOSCALE       i32 = 3


//-----------------------------------------------------------------------------
// TEMPLATE
//-----------------------------------------------------------------------------
/*type template_id struct {
    base ControlId
    template i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type template_s struct {
    id template_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_id_(base ControlId, template i32) (out template_id) {
    out.base = base
    out.template = template
    panicIfNot(is_valid_template(out), "template_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_template() (out template_id) {
    out.base = InvalidControl()
    out.template = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_template(id template_id) (out bool) {
    out = id.template >= 0 && id.template < g_templateCount && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_templates[] template_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_create(name str) (out template_id) {
    out.template = len(g_templates)
    out.base = controlCreate(name, GUI_TEMPLATE, out.template)

    var template template_s
    template.id = out

    g_templates = append(g_templates, template)
    panicIfNot(is_valid_template(out), "create_template : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_process_event(id template_id, event *event_s) (out i32) {
    panicIfNot(is_valid_template(id), "template_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_resize(id template_id) () {
    panicIfNot(is_valid_template(id), "resize_template : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_resize(id.base)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_render(id template_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_template(id), "render_template : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}*/


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type func_i32_i32_id struct {
    index i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func func_i32_i32(packageName str, functionName str) (out func_i32_i32_id) {
    out.index = glfw.func_i32_i32(packageName, functionName)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_func_i32_i32() (out func_i32_i32_id) {
    out.index = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func call_i32_i32(function func_i32_i32_id, a i32, b i32) {
    glfw.call_i32_i32(function.index, a, b)
}

//-----------------------------------------------------------------------------
// Init ...
//-----------------------------------------------------------------------------
func Init(width i32, height i32, dataDir str) {
    g_width = width
    g_height = height

    // meshes
    var attributes []i32
    attributes = []i32{3, 4, 2}
    g_opaqueVertexColoredTriangles = gfx.MeshCreate(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_opaqueVertexColoredLines = gfx.MeshCreate(gl.LINES, attributes, 20 * 2048 * 2)
    g_alphaVertexColoredTriangles = gfx.MeshCreate(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_alphaVertexColoredLines = gfx.MeshCreate(gl.LINES, attributes, 20 * 2024 * 2)
    g_fullscreenQuad = gfx.MeshCreate(gl.TRIANGLES, attributes, 6 * 3)

    gfx.MeshBegin(g_fullscreenQuad)
    gfx.MeshAppendQuad(g_fullscreenQuad, gfx.gfx_viewportBounds, mat.v4_(0.0, 1.0, 1.0, 0.0), gfx.gfx_white, gfx.gfx_viewportBounds, 0.0)
    gfx.MeshEnd(g_fullscreenQuad)

    // fonts
    //  var skycoinRunes []ui32
    //  skycoinRunes = append(skycoinRunes, 32)
    //  skycoinRunes = append(skycoinRunes, 127)
    //  printf("RUNES :%d\n", len(skycoinRunes))
    //  skycoinRunes = ui32[]{ 32U, 127U

    g_regularFont = create_font("skycoinRegular", sprintf("%s/fonts/Skycoin-Regular.ttf", dataDir),32, 127, gltext.LeftToRight)
    font_add_size(g_regularFont, g_fontSizeSmall)
    font_add_size(g_regularFont, g_fontSizeText)
    font_add_size(g_regularFont, g_fontSizeButton)
    font_add_size(g_regularFont, g_fontSizeHeader)
    font_add_size(g_regularFont, g_fontSizeTitle)

    g_boldFont = create_font("skycoinBold", sprintf("%s/fonts/Skycoin-Bold.ttf", dataDir), 32, 127, gltext.LeftToRight)
    font_add_size(g_boldFont, g_fontSizeSmall)
    font_add_size(g_boldFont, g_fontSizeText)
    font_add_size(g_boldFont, g_fontSizeButton)
    font_add_size(g_boldFont, g_fontSizeHeader)
    font_add_size(g_boldFont, g_fontSizeTitle)

    var awesomeRunes []i32
    awesomeRunes = append(awesomeRunes, 61441)
    awesomeRunes = append(awesomeRunes, 61444)
    g_awesomeBoldFont = create_font("awesomeBold", sprintf("%s/fonts/fa-solid-900.ttf", dataDir), 61441, 61841, gltext.LeftToRight)
    font_add_size(g_awesomeBoldFont, g_fontSizeSmall)
    font_add_size(g_awesomeBoldFont, g_fontSizeText)
    font_add_size(g_awesomeBoldFont, g_fontSizeHeader)

    // depth
    g_depthStencilBuffer = gfx.create_depth_buffer(gl.DEPTH_COMPONENT, g_width, g_height)

    // textures
    //g_USTexture = gfx.TextureCreate(sprintf("%s/textures/flags/us.png", dataDir), gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
    //g_JPTexture = gfx.TextureCreate(sprintf("%s/textures/flags/jp.png", dataDir), gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
    //g_BRTexture = gfx.TextureCreate(sprintf("%s/textures/flags/br.png", dataDir), gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)

    //g_USAnim = animation_create_from_texture(g_USTexture)
    //g_JPAnim = animation_create_from_texture(g_JPTexture)
    //g_BRAnim = animation_create_from_texture(g_BRTexture)

    g_skycoinTexture = gfx.TextureCreate(sprintf("%s/textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", dataDir), gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)

    //g_pumpcxTexture_0 = gfx.TextureCreate("textures/pumpcx_0.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
    //g_pumpcxTexture_1 = gfx.TextureCreate("textures/pumpcx_1.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
    //g_pumpcxAnim = animation_create()
    //animation_add_frame(g_pumpcxAnim, 10, 0, g_pumpcxTexture_0)
    //animation_add_frame(g_pumpcxAnim, 10, 0, g_pumpcxTexture_1)

    g_dumpcxAnim = animation_create_from_path(sprintf("%s/textures/dumpcx.gif", dataDir))
    g_pumpcxAnim = g_dumpcxAnim

    g_skycoinAnim = animation_create_from_texture(g_skycoinTexture)

    // layers
    g_blackLayer            = layer_create("black"            , g_black     , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_bootLayer             = layer_create("boot"             , gfx.gfx_black, gfx.gfx_black, gfx.gfx_black, gfx.gfx_black, gfx.gfx_black)
    g_popupLayer            = layer_create("popup"            , g_black_a10 , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_modalLayer            = layer_create("modal"            , g_black_a50 , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_debugBlueLayer        = layer_create("debugBlue"        , g_blue      , g_gold      , g_gold      , g_gold      , g_gold  )
    g_focusedLayer          = layer_create("focused"          , g_blue      , g_lightBlue , g_lightBlue , g_lightBlue , g_lightBlue)
    g_pageFocusedBack       = layer_create("pageFocusedBack"  , g_blue      , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_blueLayer             = layer_create("blue"             , g_blue      , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_selectedLayer         = layer_create("selected"         , g_darkBlue  , g_blue      , g_blue      , g_blue      , g_blue)
    g_pageSelectedBack      = layer_create("pageSelectedBack" , g_darkBlue  , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_debugGoldLayer        = layer_create("debugGold"        , g_gold      , g_blue      , g_blue      , g_blue      , g_blue  )
    g_goldLayer             = layer_create("gold"             , g_goldA50   , g_gold      , g_gold      , g_gold      , g_gold)
    g_goldBorderLayer       = layer_create("gold"             , g_white     , g_gold      , g_gold      , g_gold      , g_gold)
    g_textboxLayer          = layer_create("textbox"          , g_gray_1    , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_stripLayer            = layer_create("strip"            , g_gray_2    , g_gray_2    , g_gray_2    , g_gray_2    , g_gray_2)
    g_headerLayer           = layer_create("header"           , g_gray_2    , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_debugGreenLayer       = layer_create("debugGreen"       , g_green     , g_gold      , g_gold      , g_gold      , g_gold  )
    g_greenLayer            = layer_create("green"            , g_green     , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_debugRedLayer         = layer_create("debugRed"         , g_red       , g_gold      , g_gold      , g_gold      , g_gold  )
    g_redLayer              = layer_create("red"              , g_red       , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_borderFocusedLayer    = layer_create("borderFocused"    , gfx.gfx_zero, g_blue      , g_blue      , g_blue      , g_blue)
    g_pageSelectedFront     = layer_create("pageSelectedFront", gfx.gfx_zero, g_gray_3    , g_black     , g_gray_3    , g_gray_3)
    g_zeroBorderLayer       = layer_create("zeroBorder"       , gfx.gfx_zero, g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_pageFocusedFront      = layer_create("pageFocusedFront" , gfx.gfx_zero, g_lightBlue , g_lightBlue , g_lightBlue , g_lightBlue)
    g_hoverLayer            = layer_create("blueA50"          , g_blue_a50  , g_lightBlue , g_lightBlue , g_lightBlue , g_lightBlue)
    g_zeroLayer             = layer_create("zero"             , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
 
    // skins
g_blackSkin      =skin_create("black"       , g_blackLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_borderFocusedLayer,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_blackHoverSkin =skin_create("blackHover"  , g_blackLayer     ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_borderFocusedLayer,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_grayFocusedSkin=skin_create("grayFocused" , g_blackLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_windowSkin     =skin_create("window"      , g_blackLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_binderSkin     =skin_create("binder"      , g_blackLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_blueSkin       =skin_create("blue"        , g_blueLayer      ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_goldLayer         ,g_goldLayer       ,invalid_layer()   ,g_goldLayer)
g_bootSkin       =skin_create("boot"        , g_bootLayer      ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_zeroSkin       =skin_create("blackFocused", g_bootLayer      ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_debugRedSkin   =skin_create("debugRed"    , g_debugRedLayer  ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_debugGreenSkin =skin_create("debugGreen"  , g_debugGreenLayer,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_debugBlueSkin  =skin_create("debugBlue"   , g_debugBlueLayer ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_debugGoldSkin  =skin_create("debugGold"   , g_debugGoldLayer ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_goldBorderSkin =skin_create("goldBorder"  , g_goldBorderLayer,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_greenSkin      =skin_create("green"       , g_greenLayer     ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),invalid_layer()     ,g_goldLayer       ,invalid_layer()   ,invalid_layer())
g_headerSkin     =skin_create("header"      , g_headerLayer    ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_buttonSkin     =skin_create("button"      , g_headerLayer    ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_hoverSkin      =skin_create("blueA50"     , invalid_layer()  ,g_hoverLayer   ,invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_lineSkin       =skin_create("lineSkin"    , g_bootLayer      ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_itemSkin       =skin_create("itemSkin"    , g_zeroLayer      ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_modalSkin      =skin_create("popup"       , g_modalLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_popupSkin      =skin_create("modal"       , g_popupLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_redSkin        =skin_create("red"         , g_redLayer       ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),invalid_layer()     ,g_goldLayer       ,invalid_layer()   ,invalid_layer())
g_stripSkin      =skin_create("strip"       , g_stripLayer     ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_textboxSkin    =skin_create("textbox"     , g_textboxLayer   ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_binderPageSkin =skin_create("binderPage"  , g_textboxLayer   ,invalid_layer(),invalid_layer(),g_goldLayer    ,invalid_layer(),invalid_layer(),g_pageFocusedBack   ,g_pageFocusedFront,g_pageSelectedBack,g_pageSelectedFront)
g_zeroBorderSkin =skin_create("blackFocused", g_zeroBorderLayer,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
}

//-----------------------------------------------------------------------------
// SCOPE
//-----------------------------------------------------------------------------
var g_docks []bound_s
var g_offsets []rectangle_s
var g_scopeIndex i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type bound_s struct {
    left f32
    bottom f32
    right f32
    top f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type rectangle_s struct {
    x f32
    y f32
    width f32
    height f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_dock bound_s
var g_offset rectangle_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func reset_scope()() {
    panicIfNot(len(g_docks) == 0, "invalid scope")
    panicIfNot(len(g_offsets) == 0, "invalid scope")

    g_docks = resize(g_docks, 0)
    g_offsets = resize(g_offsets, 0)

    g_dock.left = 0.0
    g_dock.bottom = 0.0
    g_dock.right = gfx.gfx_width
    g_dock.top = gfx.gfx_height

    g_offset.x = 0.0
    g_offset.y = 0.0
    g_offset.width = gfx.gfx_width
    g_offset.height = gfx.gfx_height
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func push_scope()() {
    g_docks = append(g_docks, g_dock)
    g_offsets = append(g_offsets, g_offset)
    panicIfNot(len(g_docks) == len(g_offsets), "invalid scope")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func pop_scope() (){
    var scopeCount i32 = len(g_docks)
    panicIfNot(scopeCount > 0, "stack underflow")
    panicIfNot(scopeCount == len(g_offsets), "stack underflow")

    var newScopeCount i32 = scopeCount - 1
    g_dock = g_docks[newScopeCount]
    g_offset = g_offsets[newScopeCount]

    g_docks = resize(g_docks, newScopeCount)
    g_offsets = resize(g_offsets, newScopeCount)
}

//-----------------------------------------------------------------------------
// SKIN
//-----------------------------------------------------------------------------
var g_black             mat.v4 = mat.rgba_ui8( 30,  34,  39, 255)
var g_white             mat.v4 = mat.rgba_ui8(255, 251, 251, 255)
var g_blue              mat.v4 = mat.rgba_ui8(  0, 114, 255, 255)
var g_lightBlue         mat.v4 = mat.rgba_ui8(  0, 195, 255, 255)
var g_darkBlue          mat.v4 = mat.v4_mul(g_blue, mat.v4_(0.5, 0.5, 0.5, 1.0))
var g_green             mat.v4 = mat.rgba_ui8(  0, 223, 128, 255)
var g_red               mat.v4 = mat.rgba_ui8(255,   0,  78, 255)
var g_pink              mat.v4 = mat.rgba_ui8(255, 0,  0, 255)
var g_gold              mat.v4 = mat.rgba_ui8(255, 193,  37, 255)
var g_gray_0            mat.v4 = mat.rgba_ui8( 34,  38,  43, 255)
var g_gray_1            mat.v4 = mat.rgba_ui8( 41,  45,  50, 255)
var g_gray_2            mat.v4 = mat.rgba_ui8( 74,  77,  81, 255)
var g_gray_3            mat.v4 = mat.rgba_ui8(140, 142, 145, 255)
var g_gray_4            mat.v4 = mat.rgba_ui8(206, 207, 208, 255)
var g_gray_5            mat.v4 = mat.rgba_ui8(239, 240, 240, 255)
var g_gray_6            mat.v4 = mat.rgba_ui8(247, 247, 247, 255)
var g_gray_7            mat.v4 = mat.rgba_ui8(251, 251, 251, 255)

var g_black_a10 mat.v4 = mat.v4_mul(g_black, mat.v4_(0.7, 0.7, 0.7, 0.8))
var g_black_a50 mat.v4 = mat.v4_mul(g_black, mat.v4_(0.7, 0.7, 0.7, 0.8))
var g_blue_a50  mat.v4 = alpha(g_blue, 0.5)
var g_goldA50 mat.v4 = alpha(g_gold, 0.5)

var g_debugRedLayer layer_id
var g_debugGreenLayer layer_id
var g_debugBlueLayer layer_id
var g_debugGoldLayer layer_id
var g_goldLayer layer_id
var g_goldBorderLayer layer_id
var g_bootLayer layer_id
var g_blackLayer layer_id
var g_zeroBorderLayer layer_id
var g_redLayer layer_id
var g_greenLayer layer_id
var g_blueLayer layer_id
var g_hoverLayer layer_id
var g_popupLayer layer_id
var g_modalLayer layer_id
var g_headerLayer layer_id
var g_textboxLayer layer_id
var g_focusedLayer layer_id
var g_selectedLayer layer_id
var g_borderFocusedLayer layer_id
var g_stripLayer layer_id
var g_pageFocusedBack layer_id
var g_pageFocusedFront layer_id
var g_pageSelectedBack layer_id
var g_pageSelectedFront layer_id
var g_zeroLayer layer_id

var g_debugRedSkin skin_id
var g_debugGreenSkin skin_id
var g_debugBlueSkin skin_id
var g_debugGoldSkin skin_id
var g_bootSkin skin_id
var g_blackSkin skin_id
var g_blackHoverSkin skin_id
var g_zeroBorderSkin skin_id
var g_blackFocusedSkin skin_id
var g_grayFocusedSkin skin_id
var g_redSkin skin_id
var g_greenSkin skin_id
var g_blueSkin skin_id
var g_hoverSkin skin_id
var g_popupSkin skin_id
var g_modalSkin skin_id
var g_windowSkin skin_id
var g_headerSkin skin_id
var g_textboxSkin skin_id
var g_buttonSkin skin_id
var g_stripSkin skin_id
var g_binderPageSkin skin_id
var g_binderSkin skin_id
var g_zeroSkin skin_id
var g_goldBorderSkin skin_id
var g_lineSkin skin_id
var g_itemSkin skin_id

var textureLogo str = "textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png"

var g_boldFont font_id = invalid_font()
var g_regularFont font_id = invalid_font()
var g_awesomeBoldFont font_id = invalid_font()

var g_padding mat.v4 = mat.v4_(3.0, 3.0, 3.0, 3.0)
var g_spacing_x mat.v2 = mat.v2_(0.0, 3.0)
var g_spacing_y mat.v2 = mat.v2_(3.0, 0.0)
var g_spacing mat.v2 = mat.v2_(3.0, 3.0)

var g_fontSizeTitle i32 = 64
var g_fontSizeHeader i32 = 35
var g_fontSizeButton i32 = 30
var g_fontSizeText i32 = 25
var g_fontSizeSmall i32 = 20
func alpha(color mat.v4, a f32) (out mat.v4) {
    //out = mat.v4_(color.x, color.y, color.z, (color.w * a)) // ##issue_57  out.w == 0
    out.x = color.x
    out.y = color.y
    out.z = color.z
    out.w = color.w * a
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_pair_s struct {
    key ScreenId
    value ControlId
    focusList []ControlId
    currentFocus i32
}

var g_focused []control_pair_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type focus_s struct {
    focusIndex i32
    control ControlId
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func build_focus_list(focusedScreenIndex i32, parent ControlId) {
    panicIfNot(IsValidControl(parent), "build_focus_list : invalid parent")
    //ControlPrint("build_focus_list : ", parent, false)
    var index i32 = parent.control

    var unsortedList []focus_s

    var i i32 = 0
    var childCount i32 = len(g_controls[index].children)
    for i = 0; i < childCount; i = i + 1 {
        var child ControlId = g_controls[index].children[i]
        panicIfNot(IsValidControl(child), "build_focus_list : invalid child")
        var childIndex i32 = child.control
        var focusIndex i32 = g_controls[childIndex].focusIndex
        if (focusIndex >= 0) {
                //ControlPrint("FOCUSABLE : ", child, false)
                var focus focus_s
                focus.focusIndex = focusIndex
                focus.control = child
                unsortedList = append(unsortedList, focus)
            //}
        }
    }

    //printf("UNORDERED COUNT %d\n", unsortedCount)
    //sort
    var unsortedCount i32 = len(unsortedList)
    var unsorted i32 = 0
    for unsorted = 0; unsorted < unsortedCount; unsorted = unsorted + 1 {
        var focusCount i32 = len(g_focused[focusedScreenIndex].focusList)
        var focusIndex i32 = unsortedList[unsorted].focusIndex
        var focusControl ControlId = unsortedList[unsorted].control
    }

    //printf("SORTING\n")
    //sort
    i = 0
    var backUp i32 = 0
    for (i + 1 < unsortedCount) {
        var nextUnsorted i32 = i + 1
        var currentFocusIndex i32 = unsortedList[i].focusIndex
        var nextFocusIndex i32 = unsortedList[nextUnsorted].focusIndex
        var currentControl ControlId = unsortedList[i].control
        var nextControl ControlId = unsortedList[nextUnsorted].control
        if (currentFocusIndex > nextFocusIndex) {
            unsortedList[nextUnsorted].control = currentControl
            unsortedList[nextUnsorted].focusIndex = currentFocusIndex
            unsortedList[i].control = nextControl
            unsortedList[i].focusIndex = nextFocusIndex
            i = 0 // ##0 better sort...
        } else {
            backUp = i
            i = i + 1
        }
    }


    var sorted i32 = 0;
    for sorted = 0; sorted < unsortedCount; sorted = sorted + 1 {
        var focusCount i32 = len(g_focused[focusedScreenIndex].focusList)
        //printf("BUILD_SORTED INDEX %d, %d, FOCUS_COUNT %d\n", sorted, unsortedList[sorted].control.control, focusCount)
        var control ControlId = unsortedList[sorted].control
        var focusable i32 = g_controls[control.control].focusable
        build_focus_list(focusedScreenIndex, control)
        if (focusable > 0) {
            g_focused[focusedScreenIndex].focusList = append(g_focused[focusedScreenIndex].focusList, control)
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func rebuild_focus(id ScreenId) {
    panicIfNot(IsValidScreen(id), "rebuild_focus : invalid id")
    //ControlPrint("rebuild_focus : ", id.base, false)
    var i i32 = 0

    var focusedCount i32 = len(g_focused)
    var lookup ScreenId = InvalidScreen()
    var lookupIndex i32 = -1
    for i = 0; i < focusedCount; i = i + 1 {
        var key ScreenId = g_focused[i].key
        if (key.screen == id.screen) {
            printf("LOOKUP FOUND %d\n", i)
            lookup = key
            lookupIndex = i
            i = focusedCount // ##pending issue break
        }
    }

    var oldFocusIndex i32 = -1
    var oldFocusCount i32 = 0
    var oldFocus ControlId = InvalidControl()
    var remove i32 = 0
    if (IsValidScreen(lookup)) {
        //printf("VALID LOOKUP SCREEN\n")
            oldFocusIndex = g_focused[lookupIndex].currentFocus
            oldFocusCount = len(g_focused[lookupIndex].focusList)
            oldFocus = InvalidControl()
         //   printf("oldFocusIndex %d, oldFocusCount %d\n", oldFocusIndex, oldFocusCount)
            if (oldFocusIndex >= 0 && oldFocusIndex < oldFocusCount) {
                oldFocus = g_focused[lookupIndex].focusList[oldFocusIndex]
                printf("REMOVE TRUE\n")
                remove = 1
            }
    } else {
        lookup = id
        lookupIndex = focusedCount
        var pair control_pair_s
        pair.key = lookup
        g_focused = append(g_focused, pair)
    }

//    printf("lookup %d, %d, id %d, %d\n", lookup.screen, lookup.base.control, id.screen, id.base.control)
    panicIfNot(lookup.base.control == id.base.control, "rebuild_focus : internal error")

  //  printf("HERE %d\n", lookupIndex)
    g_focused[lookupIndex].currentFocus = -1
    //printf("HERE %d\n", lookupIndex)
    
    g_focused[lookupIndex].focusList = resize(g_focused[lookupIndex].focusList, 0)
    //printf("---------------------------> BEFORE BUILD_FOCUS_LIST %d, %d\n", lookupIndex, g_focused[lookupIndex].focusCount)
    build_focus_list(lookupIndex, lookup.base)
    //printf("---------------------------> AFTER BUILD_FOCUS_LIST %d, %d\n", lookupIndex, g_focused[lookupIndex].focusCount)

    var newFocusIndex i32 = -1
    var newFocus ControlId = InvalidControl()
    var newFocusCount i32 = len(g_focused[lookupIndex].focusList)
    if (IsValidControl(oldFocus)) {
        newFocusIndex = oldFocusIndex
        newFocus = oldFocus
      //  printf("RESTORING OLD FOCUS %d\n", oldFocusIndex)
        //ControlPrint("RESTORING OLD FOCUS : ", newFocus, false)
    } else if (newFocusCount > 0) {
        newFocusIndex = 0
        newFocus = g_focused[lookupIndex].focusList[0]
        printf("NEW FOCUS %d\n", newFocusIndex)
        //ControlPrint("NEW FOCUS : ", newFocus, false)
    }

    set_current_focus(lookup, lookupIndex, newFocus, newFocusIndex, remove)
    var focus i32 = 0
    var focusCount i32 = len(g_focused[lookupIndex].focusList)
    //ControlPrint("---- rebuild_focus : ", id.base, false)
    for focus = 0; focus < focusCount; focus = focus + 1 {
        var focused ControlId = g_focused[lookupIndex].focusList[focus]
        //ControlPrint("-------- rebuild_focus : ", focused, false)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_current_focus(key ScreenId, screenIndex i32, value ControlId, controlIndex i32, remove i32) {
    panicIfNot(IsValidScreen(key), "set_current_focus : invalid key")

    var currentFocus i32 = g_focused[screenIndex].currentFocus
    var focusCount i32 = len(g_focused[screenIndex].focusList)
    printf("REMOVE REMOVE %d\n", remove)
    if (currentFocus >= 0 && currentFocus < focusCount) {
        if (remove > 0) {
        var focusId ControlId = g_focused[screenIndex].focusList[currentFocus]
        panicIfNot(IsValidControl(focusId), "set_current_focus : invalid current id")
        g_controls[focusId.control].focused = 0
        ControlPrint("remove_focus : ", focusId, false)
        ControlSetParentFocus(focusId, focusId, 0)
        }
    }

    if (IsValidControl(value)) {
        var visible i32 = g_controls[value.control].visible
        panicIfNot(visible > 0, "focused not implemented")
        g_focused[screenIndex].key = key
        g_focused[screenIndex].value = value
        g_focused[screenIndex].currentFocus = controlIndex
        g_controls[value.control].focused = 1
        ControlSetParentFocus(value, value, 1)
        ControlPrint("set_current_focus : ", value, false)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func force_focus(id ControlId) {
    if (IsValidScreen(g_hotScreen) && IsValidControl(id)) {
        //printf("FORCE_FOCUS_0\n")
        var screenPair i32 = get_focus_pair(g_hotScreen)
        var currentFocus i32 = g_focused[screenPair].currentFocus
        var focusCount i32 = len(g_focused[screenPair].focusList)
        if (focusCount > 0 && currentFocus >= 0 && currentFocus < focusCount) {
            var i i32 = 0
 //      printf("FORCE_FOCUS_1\n")
            //ControlPrint("force_focuse TEST : ", id, false)
            for i = 0; i < focusCount; i = i + 1 {
                var focusedId ControlId = g_focused[screenPair].focusList[i]
                //printf("test_focus %d, %d\n", focusedId.control, id.control)
                if (focusedId.control == id.control) {
//        printf("FORCE_FOCUS_2\n")
                //ControlPrint("force_focuse DONE : ", focusedId, false)
                    set_current_focus(g_hotScreen, screenPair, id, i, 1)
                    i = focusCount
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_focus_pair(id ScreenId) (out i32) {
    out = -1
    panicIfNot(IsValidScreen(id), "get_focus_pair: invalid id")
    //ControlPrint("get_focus_pair : ", id.base, false)
    var focusedCount i32 = len(g_focused)
    var i i32 = 0
    for i = 0; i < focusedCount; i = i + 1 {
        var key ScreenId = g_focused[i].key
        if (key.screen == id.screen) {
            out = i
            i = focusedCount // ##pending issue break
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_next_focus(id ScreenId) {
    panicIfNot(IsValidScreen(id), "screen_next_focus : invalid id")
    ControlPrint("set_next_focus : ", id.base, false)
    var pair i32 = get_focus_pair(id)
    var focusedCount i32 = len(g_focused)
    if (pair >= 0 && pair < focusedCount) {
        var current i32 = g_focused[pair].currentFocus
        var count i32 = len(g_focused[pair].focusList)
        var next i32 = current
        var nextId ControlId = InvalidControl()
        var i i32 = 0
        for i = 0; i < count; i = i + 1 {
            next = (next + 1) % count
            var controlId ControlId = g_focused[pair].focusList[next]
            var visible bool = ControlParentVisible(controlId)
            if visible {
                i = count
                nextId = controlId
            }
            //printf("NEXT_FOCUS %d/%d\n", next, count)
        }
        set_current_focus(id,  pair, nextId, next, 1)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_previous_focus(id ScreenId) {
    panicIfNot(IsValidScreen(id), "screen_previous_focus : invalid id")
    ControlPrint("set_previous_focus : ", id.base, false)
    var pair i32 = get_focus_pair(id)
    var focusedCount i32 = len(g_focused)
    if (pair >= 0 && pair < focusedCount) {
        var current i32 = g_focused[pair].currentFocus
        var count i32 = len(g_focused[pair].focusList)
        var previous i32 = current
        var previousId ControlId = InvalidControl()
        var i i32 = 0
        for i = 0; i < count; i = i + 1 {
            previous = previous - 1
            if (previous < 0) {
                previous = count - 1
                //printf("PREVIOUS_FOCUS %d/%d\n", previous, count)
            }
            var controlId ControlId  = g_focused[pair].focusList[previous]
            var visible bool = ControlParentVisible(controlId)
            if visible {
                i = count
                previousId = controlId
            }
        }

        set_current_focus(id, pair, previousId, previous, 1)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func control_activate(id ControlId) {
    panicIfNot(IsValidControl(id), "control_activate : invalid id")
    ControlPrint("control_activate : ", id, false)

    var index i32 = id.control
    var guiType i32 = g_controls[index].gui_type
    if (guiType == GUI_WINDOW) {
        var guiIndex i32 = g_controls[index].gui_index
        ControlPrint("window found : ", id, false)
        var windowId window_id = window_id_(NewControlId(index), guiIndex)
        panicIfNot(is_valid_window(windowId), "control_activate : invalid window id")
        rebuild_focus(windowId)
    } else {
        var focusIndex i32 = g_controls[index].focusIndex
        if (focusIndex >= 0) {
            var i i32 = 0
            var count i32 = g_controls[index].childCount
            for i = 0; i < count; i = i + 1 {
                control_activate(g_controls[index].children[i])
            }
        }
    }
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_current_focus(id ControlId) (out ControlId) {
    /*out = InvalidControl()

    var i i32 = 0
    var focusedCount i32 = len(g_focused)
    for i = 0; i < focusedCount; i = i + 1 {
        if (g_focused[i].key.control == id.control) {
            var currrentFocus i32 = g_focused[i].currentFocus
            out = g_focused[i].focusedList[currentFocus]
        }
    }*/





    /*panicIfNot(IsValidControl(id), "control_focus : invalid id")
    ControlPrint("control_focus : ", id, false)

    var index i32 = id.control
    var focusIndex i32 = g_controls[index].focusIndex

    if (focusIndex >= 0) {
        //ControlPrint("IS_FOCUSABLE ? ", id, false)
        var focusable i32 = g_controls[index].focusable
        if (focusable > 0) {
            //ControlPrint("YES_FOCUSABLE ? ", id, false)
            out = id
            //ControlPrint("control_0 : ", out, false)
        } else {
            //out = InvalidControl()
            //ControlPrint("NO_FOCUSABLE ! ", out, false)
            //printf("out %d\n", out.control)
            var i i32 = 0
            var count i32 = g_controls[index].childCount
            for i = 0; i < count; i = i + 1 {
                //printf("i %d/%d\n", i + 1, count)
                var child ControlId = g_controls[index].children[i]
                //ControlPrint("child : ", child, false)
                var focused ControlId = control_focus(child)
                if (IsValidControl(focused)) {
                    i = count
                    out = focused
                    //ControlPrint("control_8 : ", out, false)
                }
            }
        }
    }*/
    //out = InvalidControl()
    //ControlPrint("control_9 : ", out, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_resize(id ControlId) () {
    panicIfNot(IsValidControl(id), "control_resize : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
        var pixelBounds mat.v2 = g_controls[id.control].size
        //var pixelBounds mat.v2 = mat.v2_mul(bounds, gfx.gfx_viewport_size)
        control_resize_(id, pixelBounds, mat.v2_zero)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_measure(id ControlId) (width f32, height f32) {
    panicIfNot(IsValidControl(id), "control_resize : invalid id")

    var index i32 = id.control

    var guiType i32 = g_controls[index].gui_type
    var guiIndex i32 = g_controls[index].gui_index

    width = -1.0
    height = -1.0
    if (guiType == GUI_INVALID) {
        panicIfNot(false, "invalid gui type (GUI_INVALID)")
    } else if (guiType == GUI_CONTROL) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_SCREEN) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_PICTURE) {
        width, height = PictureMeasure(NewPictureId(id, guiIndex))
    } else if (guiType == GUI_LABEL) {
        width, height = LabelMeasure(NewLabelId(id, guiIndex))
    } else if (guiType == GUI_PARTITION) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_KEYBOARD) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_WINDOW) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_GRAPH) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_SPLITTER) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_LIST) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_SCROLLER) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_LIFTER) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_BINDER) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_VECTOR) {
        panicIfNot(false, "not implemented")
    } else if (guiType == GUI_COMBO) {
        panicIfNot(false, "not implemented")
    } else {
        printf("GUI TYPE %d\n", guiType)
        panicIfNot(false, "control_resize : unknown gui type")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_resize_(id ControlId, pixelBounds mat.v2, autoBounds mat.v2) () {
    panicIfNot(IsValidControl(id), "control_resize : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
    //ControlPrint("begin_control_resize : ", id, false)
    //printf("pixelBounds %f, %f, bounds %f, %f, autoBounds %f, %f\n", pixelBounds.x, pixelBounds.y, bounds.x, bounds.y, autoBounds.x, autoBounds.y)

    var index i32 = id.control

    var dock i32 = g_controls[index].dock
    var autoscale i32 = g_controls[index].autoscale
    var scale mat.v2 = g_controls[index].scale
    var autosize i32 = g_controls[index].autosize

    var padding mat.v4 = g_controls[index].padding
    var newWidth f32 = g_controls[index].size.x
    var newHeight f32 = g_controls[index].size.y

    var paddingLeft f32 = padding.x
    var paddingBottom f32 = padding.y
    var paddingRight f32 = padding.z
    var paddingTop f32 = padding.w
    var paddingX f32 = paddingLeft + paddingRight
    var paddingY f32 = paddingBottom + paddingTop
    var maxWidth f32 = 0.0
    var maxHeight f32 = 0.0

    /*if (autosize == AUTOSIZE) {
        ControlPrint("AUTOSIZE : ", id, false)
    }*/


    var minX f32 = mat.FLOAT_MAX
    var minY f32 = mat.FLOAT_MAX

    var maxX f32 = mat.FLOAT_MIN
    var maxY f32 = mat.FLOAT_MIN

    var count i32 = len(g_controls[index].children)
    for i := 0; i < count; i = i + 1 {
        var child ControlId = g_controls[index].children[i]
        var childIndex i32 = child.control
        panicIfNot(IsValidControl(child), "control_resize : invalid child control")
        var childVisible i32 = g_controls[child.control].visible
        if (childVisible > 0) {
            var guiType i32 = g_controls[childIndex].gui_type
            var guiIndex i32 = g_controls[childIndex].gui_index

            if (guiType == GUI_INVALID) {
               panicIfNot(false, "invalid gui type (GUI_INVALID)")
            } else if (guiType == GUI_CONTROL) {
                panicIfNot(guiIndex == childIndex, "unexpected error")
                control_resize(NewControlId(guiIndex))
            } else if (guiType == GUI_SCREEN) {
                panicIfNot(false, "unidd recursive screen")
            } else if (guiType == GUI_PICTURE) {
                PictureResize(NewPictureId(child, guiIndex))
            } else if (guiType == GUI_LABEL) {
                LabelResize(NewLabelId(child, guiIndex))
            } else if (guiType == GUI_PARTITION) {
                partition_resize(partition_id_(child, guiIndex))
            } else if (guiType == GUI_KEYBOARD) {
                keyboard_resize(keyboard_id_(child, guiIndex))
            } else if (guiType == GUI_WINDOW) {
                window_resize(window_id_(child, guiIndex))
            } else if (guiType == GUI_GRAPH) {
                graph_resize(graph_id_(child, guiIndex))
            } else if (guiType == GUI_SPLITTER) {
                splitter_resize(splitter_id_(child, guiIndex))
            } else if (guiType == GUI_LIST) {
                list_resize(list_id_(child, guiIndex))
            } else if (guiType == GUI_SCROLLER) {
                scroller_resize(scroller_id_(child, guiIndex))
            } else if (guiType == GUI_LIFTER) {
                lifter_resize(lifter_id_(child, guiIndex))
            } else if (guiType == GUI_BINDER) {
                binder_resize(binder_id_(child, guiIndex))
            } else if (guiType == GUI_VECTOR) {
                vector_resize(vector_id_(child, guiIndex))
            } else if (guiType == GUI_COMBO) {
                combo_resize(combo_id_(child, guiIndex))
            } else {
                printf("GUI TYPE %d\n", guiType)
                    panicIfNot(false, "control_resize : unknown gui type")
            }

            var position mat.v2 = g_controls[child.control].renderPosition
                var size mat.v2 = g_controls[child.control].size

                maxWidth = mat.max(maxWidth, size.x)
                maxHeight = mat.max(maxHeight, size.y)

                minX = mat.min(minX, position.x)
                minY = mat.min(minY, position.y)
                maxX = mat.max(maxX, position.x + size.x)
                maxY = mat.max(maxY, position.y + size.y)

                /*if (index == 36) {
                  ControlPrint("control_resize child ", child, false)
                  printf("%s, %d/%d : MAXWIDTH %f, MAXHEIGHT %f, POSX %f, POSY %f, SIZEX %f, SIZEY %f\n",
                  g_controls[child.control].name, i + 1, count, maxWidth, maxHeight,
                  position.x, position.y, size.x, size.y)
                  }*/
        }
    }


    maxWidth = maxX - minX
    maxHeight = maxY - minY
    /*if (index == 36) {
      printf("MINY %f, MAXY %f, MAXHEIGHT %f, PADDINGY %f\n", minY, maxY, maxHeight, paddingY)
      }*/

            var scaleW f32 = scale.x
            var scaleH f32 = scale.y
    if (autoscale == AUTOSCALE || autoscale == AUTOSCALE_X || autoscale == AUTOSCALE_Y) {
        if (autoBounds.x > 0 && autoBounds.y > 0) {
            //ControlPrint("AUTOSCALE : ", id, false)
            //printf("scale %f, %f, newWidth %f, newHeight %f, autoBounds %f, %f\n", scale.x, scale.y, newWidth, newHeight, autoBounds.x, autoBounds.y)
            if ((autoscale & AUTOSCALE_X) == AUTOSCALE_X) {
                panicIfNot((autosize & AUTOSIZE_X) == 0, "AUTOSCALE_X is not compatible with AUTOSIZE_X")
                var tmp f32 = scaleW
                scaleW = newWidth / autoBounds.x
                scaleH = scaleW * scaleH / tmp
            }

            if ((autoscale & AUTOSCALE_Y) == AUTOSCALE_Y) {
                panicIfNot((autosize & AUTOSIZE_Y) == 0, "AUTOSCALE_Y is not compatible with AUTOSCALE_Y")
                var tmp f32 = scaleH
                scaleH = newHeight / autoBounds.y
                scaleW = scaleH * scaleW / tmp
            }

            if (autoscale == AUTOSCALE) {
                if (scaleW < scaleH) {
                    scaleH = scaleW
                    var newScale mat.v2 = mat.v2_(scaleW, scaleH/* / gfx.gfx_ratio_y*/)
                    g_controls[index].scale = newScale
                    //ControlPrint("after_pop", id, false)

                } else {
                    scaleW = scaleH
                    var newScale mat.v2 = mat.v2_(scaleW/* * gfx.gfx_ratio_x*/, scaleH)
                    g_controls[index].scale = newScale
                }
            } else {
                var newScale mat.v2 = mat.v2_(scaleW, scaleH)
                g_controls[index].scale = newScale
            }
        }
    } else {
        panicIfNot(autoscale == AUTOSCALE_NONE, "invalid AUTOSCALE value")
    }

    if (autosize == AUTOSIZE || autosize == AUTOSIZE_X || autosize == AUTOSIZE_Y) {
        if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
            //panicIfNot(dock == DOCK_NONE || dock == DOCK_LEFT || dock == DOCK_RIGHT, "AUTOSIZE_X is not compatible with DOCK_Y")
            panicIfNot((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
            newWidth = mat.max(maxWidth + paddingX, autoBounds.x) * scaleW// - paddingX
            //if (index == 36) {
            //    printf("NEW_WIDTH %f, MAX_WIDTH %f, AUTO_BOUNDS_X %f, PADDING %f\n", newWidth, maxWidth, autoBounds.x, paddingX)
            //}
        }
        if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
            //panicIfNot(dock == DOCK_NONE || dock == DOCK_BOTTOM || dock == DOCK_TOP, "AUTOSIZE_Y is not compatible with DOCK_X")
            panicIfNot((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
            newHeight = mat.max(maxHeight +  paddingY, autoBounds.y) * scaleH// - paddingY
            /*if (index == 36) {
              printf("NEW_HEIGHT %f, AUTO_BOUNDS_Y %f\n", maxHeight, autoBounds.y)
              }*/
        }

        g_controls[index].size = mat.v2_(newWidth, newHeight)
        //ControlPrint("NEW_SIZE : ", id, false)
    } else {
        panicIfNot(autosize == AUTOSIZE_NONE, "invalid AUTOSIZE value")
    }
    /*if (id.control == 36) {
      ControlPrint("end_control_resize", id, false)
      }*/
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func align_control(id ControlId, align i32, posx f32, posy f32, width f32, height f32, contX f32, contY f32, contW f32, contH f32, padding mat.v4) (x f32, y f32) {
    x = posx
    y = posy

    if (align == ALIGN_CENTER) {
        x = contX + (contW - width) / 2.0
        y = contY + (contH - height) / 2.0
        /*if (id.control == 57) {
          ControlPrint("align_center : ", id, false)
          printf("ALIGN_CENTER CONTX %f, CONTY %f, CONTW %f, CONTH %f, WIDTH %f, HEIGHT %f OFFSET X %f, OFFSET Y %f\n", contX, contY, contW, contH, width, height, x, y)
          }*/
    } else if (align == ALIGN_HORZ_BOTTOM) {
        x = contX + (contW - width) / 2.0
        y = contY + padding.y
        //ControlPrint(index, "ALIGN_HORZ_BOTTOM : ")
    } else if (align == ALIGN_HORZ_TOP) {
        panicIfNot(false, "ALIGN_HORZ_TOP not implemented")
    } else if (align == ALIGN_VERT_LEFT) {
        panicIfNot(false, "ALIGN_VERT_LEFT not implemented")
    } else if (align == ALIGN_VERT_RIGHT) {
        panicIfNot(false, "ALIGN_VERT_RIGHT not implemented")
    } else if (align == ALIGN_LEFT_BOTTOM) {
        panicIfNot(false, "ALIGN_LEFT_BOTTOM not implemented")
    } else if (align == ALIGN_RIGHT_BOTTOM) {
        panicIfNot(false, "ALIGN_RIGHT_BOTTOM not implemented")
    } else if (align == ALIGN_HORZ) {
        panicIfNot(false, "ALIGN_HORZ not implemented")
    } else if (align == ALIGN_VERT) {
        panicIfNot(false, "ALIGN_VERT not implemented")
    } else if (align == ALIGN_LEFT_TOP) {
        panicIfNot(false, "ALIGN_LEFT_TOP not implemented")
    } else if (align == ALIGN_RIGHT_TOP) {
        panicIfNot(false, "ALIGN_RIGHT_TOP not implemented")
    } else if (align == ALIGN_LEFT) {
        panicIfNot(false, "ALIGN_LEFT not implemented")
    } else if (align == ALIGN_RIGHT) {
        x = contX + contW - width - padding.z
        y = contY + padding.w + (contH - height - padding.y - padding.w) / 2.0
        /*if (id.control == 153) {
          printf("ALIGN_CONTROL CONTX %f, CONTY %f, CONTW %f, CONTH %f, WIDTH %f, HEIGHT %f OFFSET X %f, OFFSET Y %f\n", contX, contY, contW, contH, width, height, x, y)
          }*/
    } else if (align == ALIGN_BOTTOM) {
        panicIfNot(false, "ALIGN_BOTTOM not implemented")
    } else if (align == ALIGN_TOP) {
        panicIfNot(false, "ALIGN_TOP not implemented")
    } else if (align != ALIGN_NONE) {
        //x = bounds.x
        //y = bounds.y
        //w = bounds.z
        //h = bounds.w
        //} else {
        panicIfNot(false, "invalid align property")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_redock(id ControlId, padding mat.v4) () {
    panicIfNot(IsValidControl(id), "control_redock : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
        /*if (id.control == 85) {
          ControlPrint("begin_control_redock : ", id, false)
          }*/

        var index i32 = id.control
        var w f32 = 0.0
        var h f32 = 0.0
        var x f32 = 0.0
        var y f32 = 0.0

        var dock i32 = g_controls[index].dock
        var align i32 = g_controls[index].align
        var autosize i32 = g_controls[index].autosize
        var autoscale i32 = g_controls[index].autoscale
        var size mat.v2 = g_controls[index].size
        var position mat.v2 = g_controls[index].position
        var parentPadding mat.v4 = g_controls[index].padding

        var paddingLeft f32 = padding.x
        var paddingBottom f32 = padding.y
        var paddingRight f32 = padding.z
        var paddingTop f32 = padding.w

        var paddingX f32 = paddingLeft + paddingRight
        var paddingY f32 = paddingBottom + paddingTop

        /*if (dock != DOCK_NONE) {
          panicIfNot(align == ALIGN_NONE, "control_redock : incompatible align & dock options")
          }*/

        if (dock == DOCK_FILL) {
            x = g_dock.left + paddingLeft
            w = g_dock.right - g_dock.left - paddingX
            h = g_dock.top - g_dock.bottom - paddingY
            y = g_dock.bottom + paddingBottom
            //panicIfNot(mat.is_nan(y) == false, "control_resize : DOCK_FILL y nan")
            //panicIfNot(autosize == AUTOSIZE_NONE, "control_redock : DOCK_FILL is not compatible with AUTOSIZE")
            /*if (index == 153) {
              ControlPrint("DOCK_FILL : ", id, false)
              }*/
        } else if (dock == DOCK_LEFT) {
            x = g_dock.left + paddingLeft
            w = size.x
            h = g_dock.top - g_dock.bottom - paddingY
            y = g_dock.top - h - paddingTop
            //panicIfNot(mat.is_nan(y) == false, "control_resize : DOCK_LEFT y nan")
            g_dock.left = x + w
            //panicIfNot((autosize & AUTOSIZE_Y) == 0, "control_redock : DOCK_LEFT is not compatible with AUTOSIZE_Y")
        } else if (dock == DOCK_RIGHT) {
            w = size.x
            x = g_dock.right - w - paddingLeft
            h = g_dock.top - g_dock.bottom - paddingY
            y = g_dock.top - h - paddingTop
            g_dock.right = x
            //panicIfNot((autosize & AUTOSIZE_Y) == 0, "control_redock : DOCK_RIGHT is not compatible with AUTOSIZE_Y")
        } else if (dock == DOCK_TOP) {
            x = g_dock.left + paddingLeft
            w = g_dock.right - g_dock.left - paddingX
            h = size.y
            y = g_dock.top - h - paddingTop
            //panicIfNot(mat.is_nan(y) == false, "control_resize : DOCK_TOP y nan")
            /*if (index == 29 || index == 30) {
              printf("DOCK_TOP %f, %f, %f, %f\n", g_dock.top, h, paddingTop, y)
              }*/
            g_dock.top = y
            //panicIfNot((autosize & AUTOSIZE_X) == 0, "control_redock : DOCK_TOP is not compatible with AUTOSIZE_X")
            //ControlPrint("DOCK_TOP : ", id, false)
            //printf("DOCK_TOP %f, %f, %f\n", g_dock.top, y, h)
        } else if (dock == DOCK_BOTTOM) {
            x = g_dock.left + paddingLeft
            w = g_dock.right - g_dock.left - paddingX
            h = size.y
            y = g_dock.bottom + paddingBottom// + h
            g_dock.bottom = y + h
            //panicIfNot(mat.is_nan(y) == false, "control_resize : DOCK_BOTTOM y nan")
            //panicIfNot((autosize & AUTOSIZE_X) == 0, "control_redock : DOCK_BOTTOM is not compatible with AUTOSIZE_X")
            //ControlPrint("DOCK_BOTTOM : ", id, false)
        } else if (dock == DOCK_NONE) {
            x = position.x
            y = position.y
            w = size.x
            h = size.y
            //panicIfNot(mat.is_nan(y) == false, "control_resize : DOCK_NONE y nan")
            /*if (index == 50) {
              ControlPrint("control_redock : ", id, false)
              printf("x %f, y %f, w %f, h %f\n", x, y, w, h)
              }*/
        } else {
            panicIfNot(false, "invalid dock value")
        }

        var contX f32 = g_dock.left
        var contY f32 = g_dock.bottom
        var contW f32 = g_offset.width//g_dock.right - g_dock.left//g_offset.width
        var contH f32 = g_offset.height//g_dock.top - g_dock.bottom//g_offset.height

        /*if (index == 153) {
          ControlPrint("befor align : ", id, false)
          printf("redock %f, %f\n", x, y)
          }*/
        x, y = align_control(id, align, x, y, size.x, size.y, contX, contY, contW, contH, padding)
        /*if (index == 153) {
          ControlPrint("after align : ", id, false)
          printf("redock %f, %f\n", x, y)
          }*/
        push_scope()

        //panicIfNot(mat.is_nan(y) == false, "control_resize : y nan")
        g_offset.x = g_offset.x + x
        g_offset.y = g_offset.y + y
        g_offset.width = w
        g_offset.height = h

        g_dock.left = 0.0
        g_dock.bottom = 0.0
        g_dock.right = w
        g_dock.top = h

        //ControlPrint(index, "child")
        var count i32 = len(g_controls[index].children)
        for i := 0; i < count; i = i + 1 {
            var child ControlId = g_controls[index].children[i]
            panicIfNot(IsValidControl(child), "control_redock : invalid child control")
            var childVisible i32 = g_controls[child.control].visible
            if (childVisible > 0) {
                ///printf("REDOCK_CHILD %d/%d\n", i + 1, count)
                var childControl i32 = child.control
                var guiType i32 = g_controls[childControl].gui_type
                var guiIndex i32 = g_controls[childControl].gui_index

                if (guiType == GUI_INVALID) {
                    panicIfNot(false, "invalid gui type (GUI_INVALID)")
                } else if (guiType == GUI_CONTROL) {
                    panicIfNot(guiIndex == childControl, "unexpected error")
                    /*if (index == 85) {
                      ControlPrint("REDOCK :", child, false)
                      }*/
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_SCREEN) {
                    panicIfNot(false, "unidd recursive screen")
                } else if (guiType == GUI_PICTURE) {
                    //redock_picture(NewPictureId(child, guiIndex))
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_LABEL) {
                    //redock_label(NewLabelId(child, guiIndex))
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_PARTITION) {
                    //redock_partition(partition_id_(child, guiIndex))
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_KEYBOARD) {
                    //redock_keyboard(keyboard_id_(child, guiIndex))
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_WINDOW) {
                    //redock_window(window_id_(child, guiIndex))
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_GRAPH) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_SPLITTER) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_LIST) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_SCROLLER) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_LIFTER) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_BINDER) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_VECTOR) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else if (guiType == GUI_COMBO) {
                    control_redock(NewControlId(childControl), parentPadding)
                } else {
                    //ControlPrint("control_redock parent : ", id, false)
                    //ControlPrint("control_redock child : ", child, false)
                    panicIfNot(false, "control_redock : unknown gui type")
                }
            }
        }

        g_controls[index].renderPosition = mat.v2_(g_offset.x, g_offset.y)
        //panicIfNot(mat.is_nan(g_offset.y) == false, "control_resize : nan")
        //ControlPrint("after control_redock : ", id, false)
        //g_controls[index].renderSize = mat.v2_(g_offset.width, g_offset.height)
        var newWidth f32 = g_offset.width
        var newHeight f32 = g_offset.height

        if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
            panicIfNot((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
            //panicIfNot(dock == DOCK_NONE || dock == DOCK_LEFT || dock == DOCK_RIGHT, "AUTOSIZE_X is not compatible with DOCK_Y")
            newWidth = g_controls[index].size.x
            //newWidth = newWidth - paddingX // ##pending_7
            /*if (index == 36) {
              printf("AUTOSIZE NEW WIDTH %f, %f, %f\n", newWidth, g_controls[index].size.x, paddingX)
              }*/
        }
        if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
            panicIfNot((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
            //panicIfNot(dock == DOCK_NONE || dock == DOCK_TOP || dock == DOCK_BOTTOM, "AUTOSIZE_Y is not compatible with DOCK_X")
            newHeight = g_controls[index].size.y
            //newHeight = newHeight - paddingY // ##pending_7
            //printf("AUTOSIZE NEW HEIGHT %f, %f, %f\n", newHeight, g_controls[index].size.y, paddingY)
        }
        g_controls[index].size = mat.v2_(newWidth, newHeight)

        /*if (id.control == 50) {
          ControlPrint("end_control_redock", id, false)
          }*/
        pop_scope()
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_surface(opaque gfx.MeshId, alpha gfx.MeshId, bounds mat.v4, color mat.v4, clip mat.v4, depth f32) () {
    if (color.w > 0) {
        var mesh gfx.MeshId = opaque
        if (color.w < 1.0) {
            mesh = alpha
        }
        gfx.MeshAppendQuad(mesh, bounds, mat.v4_(0.0, 0.0, 1.0, 1.0), color, clip, depth)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_border(opaque gfx.MeshId, alpha gfx.MeshId, bounds mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4, clip mat.v4, depth f32) () {
    var x0 f32 = bounds.x
    var y0 f32 = bounds.y
    var x1 f32 = x0 + bounds.z
    var y1 f32 = y0 + bounds.w

    if (left.w > 0) {
        var mesh gfx.MeshId = opaque
        if (left.w < 1.0) {
            mesh = alpha
        }
        gfx.MeshAppendLine(mesh, mat.v4_(x0, y0, x0, y1), left, clip, depth)
    }

    if (bottom.w > 0) {
        var mesh gfx.MeshId = opaque
        if (bottom.w < 1.0) {
            mesh = alpha
        }
        gfx.MeshAppendLine(mesh, mat.v4_(x0, y0, x1, y0), bottom, clip, depth)
    }

    if (right.w > 0) {
        var mesh gfx.MeshId = opaque
        if (right.w < 1.0) {
            mesh = alpha
        }
        gfx.MeshAppendLine(mesh, mat.v4_(x1, y0, x1, y1), right, clip, depth)
    }

    if (top.w > 0) {
        var mesh gfx.MeshId = opaque
        if (top.w < 1.0) {
            mesh = alpha
        }
        gfx.MeshAppendLine(mesh, mat.v4_(x0, y1, x1, y1), top, clip, depth)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func compute_depth(stack i32) (out f32) {
    out = i32.f32(stack) / 100.0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func layer_render(layer layer_id, renderBounds mat.v4, renderClips mat.v4, depth f32) {
    if is_valid_layer(layer) {
        render_surface(g_opaqueVertexColoredTriangles, g_alphaVertexColoredTriangles, renderBounds, g_layers[layer.layer].surface, renderClips, depth)
        render_border(g_opaqueVertexColoredLines, g_alphaVertexColoredLines,
        renderBounds,
        g_layers[layer.layer].left,
        g_layers[layer.layer].bottom,
        g_layers[layer.layer].right,
        g_layers[layer.layer].top,
        renderClips, depth + 0.00001)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_render(id ControlId, clip mat.v4, stack i32) () {
    //fps.Start(g_profileRenderControlFull)

    panicIfNot(IsValidControl(id), "control_render : invalid control index")

    var index i32 = id.control
    var visible i32 = g_controls[index].visible
    if (visible > 0) {
        var renderBounds mat.v4 = mat.v4_v2v2(g_controls[index].renderPosition, g_controls[index].size)
        var renderClips mat.v4 = gfx.push_scissor(g_controls[index].name, renderBounds)
        //fps.Start(g_profileControlRender)
        var skin skin_id = g_controls[index].skin
        panicIfNot(is_valid_skin(skin) || skin.skin == -1, "control_render : invalid control skin")
        if is_valid_skin(skin) {
            var depth f32 = compute_depth(stack)
            var focused i32 = g_controls[index].focused
            var childFocused i32 = g_controls[index].childFocused
            var selected i32 = g_controls[index].selected
            var backLayer layer_id = g_skins[skin.skin].back
            var frontLayer layer_id = g_skins[skin.skin].front

            if (focused > 0 || childFocused > 0) {
                var backFocusedLayer layer_id = g_skins[skin.skin].focused_back
                if (is_valid_layer(backFocusedLayer)) {
                    backLayer = backFocusedLayer
                }
                var frontFocusedLayer layer_id = g_skins[skin.skin].focused_front
                if (is_valid_layer(frontFocusedLayer)) {
                    frontLayer = frontFocusedLayer
                }
            } else if (selected > 0) {
                var backSelectedLayer layer_id = g_skins[skin.skin].selected_back
                if (is_valid_layer(backSelectedLayer)) {
                    backLayer = backSelectedLayer
                }
                var frontSelectedLayer layer_id = g_skins[skin.skin].selected_front
                if (is_valid_layer(frontSelectedLayer)) {
                    frontLayer = frontSelectedLayer
                }
            }

            var hovered i32 = g_controls[id.control].hovered
            layer_render(backLayer, renderBounds, renderClips, depth)
            if (hovered > 0) {
                layer_render(g_skins[skin.skin].hoverBack, renderBounds, renderClips, depth + 0.05)
            }
            layer_render(frontLayer, renderBounds, renderClips, depth + 0.1)
            if (hovered > 0) {
                layer_render(g_skins[skin.skin].hoverFront, renderBounds, renderClips, depth + 0.15)
            }
        }
        //fps.Stop(g_profileControlRender)

        //fps.Start(g_profileControlRenderChild)
        var childStack i32 = stack + 1
        var count i32 = len(g_controls[index].children)
        for i := 0; i < count; i = i + 1 {
            var child ControlId = g_controls[index].children[i]
            panicIfNot(IsValidControl(child), "control_render : invalid child control")
            var childVisible i32 = g_controls[child.control].visible
            if (childVisible > 0) {
                var guiType i32 = g_controls[child].gui_type
                var guiIndex i32 = g_controls[child].gui_index

                if (guiType == GUI_INVALID) {
                    panicIfNot(false, "invalid gui type (GUI_INVALID)")
                } else if (guiType == GUI_CONTROL) {
                    //ControlPrint(guiIndex, "control_render_child GUI_CONTROL : ")
                    panicIfNot(child.control == guiIndex, "unexpected error")
                    control_render(child, renderBounds, childStack)
                } else if (guiType == GUI_SCREEN) {
                    panicIfNot(false, "unidd recursive screen")
                } else if (guiType == GUI_PICTURE) {
                    PictureRender(NewPictureId(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_LABEL) {
                    LabelRender(NewLabelId(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_PARTITION) {
                    partition_render(partition_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_KEYBOARD) {
                    keyboard_render(keyboard_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_WINDOW) {
                    window_render(window_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_GRAPH) {
                    graph_render(graph_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_SPLITTER) {
                    splitter_render(splitter_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_LIST) {
                    list_render(list_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_SCROLLER) {
                    scroller_render(scroller_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_LIFTER) {
                    lifter_render(lifter_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_BINDER) {
                    binder_render(binder_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_VECTOR) {
                    vector_render(vector_id_(child, guiIndex), renderBounds, childStack)
                } else if (guiType == GUI_COMBO) {
                    combo_render(combo_id_(child, guiIndex), renderBounds, childStack)
                } else {
                    printf("GUI TYPE %d\n", guiType)
                    panicIfNot(false, "control_render : unknown gui type")
                }
            }
        }
        gfx.pop_scissor()
        //ControlPrint("after control_render : ", id, false)
        //fps.Stop(g_profileControlRenderChild)
    }
    //fps.Stop(g_profileRenderControlFull)
}

//-----------------------------------------------------------------------------
// SPLITTER
//-----------------------------------------------------------------------------
type splitter_id struct {
    base ControlId
    splitter i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type splitter_s struct {
    id splitter_id
    direction i32
    master ControlId
    slave ControlId

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var SPLIT_NONE i32 = 0
var SPLIT_LEFT i32 = 1
var SPLIT_RIGHT i32 = 2
var SPLIT_TOP i32 = 3
var SPLIT_BOTTOM i32 = 4
var SPLIT_HORZ i32 = 5
var SPLIT_VERT i32 = 6

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_id_(base ControlId, splitter i32) (out splitter_id) {
    out.base = base
    out.splitter = splitter
    panicIfNot(is_valid_splitter(out), "splitter_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_splitter(id splitter_id) (out bool) {
    out = id.splitter >= 0 && id.splitter < len(g_splitters) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_set_direction(id splitter_id, direction i32) {
    panicIfNot(is_valid_splitter(id), "splitter_set_direction : invalid id")
    g_splitters[id.splitter].direction = direction
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_set_controls(id splitter_id, master ControlId, slave ControlId) {
    panicIfNot(is_valid_splitter(id), "splitter_set_master : invalid id")
    ControlClearChildren(id.base)
    g_splitters[id.splitter].master = master
    ControlAddChild(id.base, master)

    g_splitters[id.splitter].slave = slave
    ControlAddChild(id.base, slave)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_splitters[] splitter_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_create(name str) (out splitter_id) {
    out.splitter = len(g_splitters)
    out.base = controlCreate(name, GUI_SPLITTER, out.splitter)

    var splitter splitter_s

    splitter.direction = SPLIT_NONE
    splitter.master = InvalidControl()
    splitter.slave = InvalidControl()

    g_splitters = append(g_splitters, splitter)
    panicIfNot(is_valid_splitter(out), "splitter_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_process_event(id splitter_id, event *event_s) (out i32) {
    panicIfNot(is_valid_splitter(id), "splitter_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_resize(id splitter_id) () {
    panicIfNot(is_valid_splitter(id), "resize_splitter : invalid id")
    control_resize(id.base)
    //ControlPrint("splitter_resize : ", id.base, false)
    var splitterIndex i32 = id.splitter
    var direction i32 = g_splitters[splitterIndex].direction
    //printf("SPLIT %d, %d, %d\n", id.splitter, g_splitters[id.splitter].direction, direction)

    var master ControlId = g_splitters[splitterIndex].master
    var slave ControlId = g_splitters[splitterIndex].slave

    //ControlPrint("splitter_resize : ", id.base, false)
    //printf("MASTER %d\n", master.control)
    panicIfNot(IsValidControl(master), "splitter_resize : invalid master")
    var masterIndex i32 = master.control

    panicIfNot(IsValidControl(slave), "splitter_resize : invalid slave")
    var slaveIndex i32 = slave.control

    var controlIndex i32 = id.base.control
    var splitterPosition mat.v2 = g_controls[controlIndex].renderPosition
    var splitterSize mat.v2 = g_controls[controlIndex].size

    var padding mat.v4 = g_controls[controlIndex].padding
    var spacing mat.v2 = g_controls[controlIndex].spacing

    if (direction == SPLIT_HORZ) {
        var width f32 = (splitterSize.x - padding.x - padding.z - spacing.x) / 2.0
        var height f32 = (splitterSize.y - padding.y - padding.w)

        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(width, height)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveX f32 = padding.x + spacing.x + width
        var slavePosition mat.v2 = mat.v2_(slaveX, padding.y)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else if (direction == SPLIT_VERT) {
        var width f32 = (splitterSize.x - padding.x - padding.z)
        var height f32 = (splitterSize.y - padding.y - padding.w - spacing.y) / 2.0

        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(width, height)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveY f32 = padding.y + spacing.y + height
        var slavePosition mat.v2 = mat.v2_(padding.x, slaveY)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else if (direction == SPLIT_BOTTOM) {
        var oldMasterSize mat.v2 = g_controls[masterIndex].size
        var width f32 = (splitterSize.x - padding.x - padding.z)
        var height f32 = (splitterSize.y - padding.y - padding.w - spacing.y - oldMasterSize.y)

        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(width, oldMasterSize.y)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveY f32 = padding.y + oldMasterSize.y + spacing.y
        var slavePosition mat.v2 = mat.v2_(padding.x, slaveY)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else if (direction == SPLIT_LEFT) {
        var oldMasterSize mat.v2 = g_controls[masterIndex].size
        var width f32 = (splitterSize.x - padding.x - padding.z - spacing.x - oldMasterSize.x)
        var height f32 = (splitterSize.y - padding.y - padding.w)

        //ControlPrint("splitter_resize : ", master, false)
        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(oldMasterSize.x, height)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveX f32 = padding.x + oldMasterSize.x + spacing.x
        //printf("MASTER_POSITION %f\n", masterPosition.x)
        //printf("SLAVE POSITION %f\n", slaveX)
        var slavePosition mat.v2 = mat.v2_(slaveX + 10.0, padding.y)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else {
        panicIfNot(false, "splitter_resize : not implemented")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_render(id splitter_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_splitter(id), "render_splitter : invalid id")
    control_render(id.base, clip, stack)

    //var direction i32 = g_splitters[id.splitter].direction
    //if (direction == SPLIT_LEFT) {
    //ControlPrint("splitter_render : ", id.base, false)
    //var master ControlId = g_splitters[id.splitter].master
    //var slave ControlId = g_splitters[id.splitter].slave
    //ControlPrint("splitter_render : MASTER :", master, false)
    //ControlPrint("splitter_render : SLAVE :", slave, false)
    //}
}

//-----------------------------------------------------------------------------
// WINDOW
//-----------------------------------------------------------------------------
var g_windows[] window_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_id struct {
    base ControlId
    window i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_s struct {
    id window_id
    header ControlId
    caption LabelId
    container ControlId
    strip ControlId
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_id_(base ControlId, window i32) (out window_id) {
    out.base = base
    out.window = window
    panicIfNot(is_valid_window(out), "window_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_window(id window_id) (out bool) {
    out = id.window >= 0 && id.window < len(g_windows) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_caption(id window_id, text str) () {
    panicIfNot(is_valid_window(id), " window_set_caption : invalid id")
    LabelSetText(g_windows[id.window].caption, text)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_containee(id window_id, containee ControlId) {
    panicIfNot(is_valid_window(id), "window_set_containee : invalid id")
    panicIfNot(IsValidControl(containee), "window_set_containee : invalid containee")

    var container ControlId = g_windows[id.window].container
    panicIfNot(IsValidControl(container), "window_set_containee : invalid container")

    ControlAddChild(container, containee)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_create(name str) (out window_id) {
    out.base = controlCreate(name, GUI_WINDOW, out.window)
    out.window = len(g_windows)

    var window window_s
    window.id = out

    var padding mat.v4 = mat.v4_(5.0, 5.0, 5.0, 5.0)
    var padding1 mat.v4 = mat.v4_(3.0, 3.0, 3.0, 3.0)
    {
        var header ControlId = ControlCreate("header") // ##pending := 
        ControlAddChild(out.base, header)
        ControlSetSkin(header, g_headerSkin)
        ControlSetSize(header, mat.v2_(0.0, 0.1))
        ControlSetDock(header, DOCK_TOP)
        ControlSetAutosize(header, AUTOSIZE_Y)
        window.header = header

        {
            var caption LabelId = LabelCreate("label")
            ControlAddChild(header, caption.base)
            ControlSetDock(caption.base, DOCK_FILL)
            ControlSetAutosize(caption.base, AUTOSIZE_Y)
            LabelSetAlign(caption, ALIGN_CENTER)
            LabelSetFont(caption, g_boldFont) // ##1 skin
            LabelSetColor(caption, g_white)
            LabelSetSize(caption, g_fontSizeText)
            window.caption = caption
        }
    }

    {
        var container ControlId = ControlCreate("container")
        ControlAddChild(out.base, container)
        //ControlSetSkin(container, g_redSkin)
        ControlSetDock(container, DOCK_TOP)
        ControlSetAutosize(container, AUTOSIZE)
        ControlSetPadding(container, padding1)
        window.container = container
    }

    {
        var strip ControlId = ControlCreate("strip")
        ControlAddChild(out.base, strip)
        //ControlSetSkin(strip, g_blueSkin)
        ControlSetBounds(strip, mat.v4_(0.0, 0.0, 0.0, 0.12))
        ControlSetDock(strip, DOCK_TOP)
        ControlSetAutosize(strip, AUTOSIZE_Y)
        ControlSetPadding(strip, padding)
        window.strip = strip
    }

    g_windows = append(g_windows, window)
    panicIfNot(is_valid_window(out), "window_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_add_button(id window_id, name str, caption str, packageName str, functionName str) {
    panicIfNot(is_valid_window(id), "window_add_button : invalid id")

   var button LabelId = LabelCreate(name)
   ControlSetSkin(button.base, g_buttonSkin)
   ControlSetBounds(button.base, mat.v4_(0.0, 0.0, 50.0, 0.0))
   ControlSetDock(button.base, DOCK_RIGHT)
   ControlSetAutosize(button.base, AUTOSIZE_Y)
   ControlSetPadding(button.base, mat.v4_(0.0, 0.0, 0.0, 0.0))
   ControlSetFocusable(button.base, 1)
   LabelSetAlign(button, ALIGN_CENTER)
   LabelSetColor(button, g_white)
   LabelSetFont(button, g_boldFont)
   LabelSetText(button, caption)
   LabelSetSize(button, g_fontSizeSmall)
   LabelSetOnState(button, packageName, functionName)

   var strip ControlId = g_windows[id.window].strip
   ControlAddChild(strip, button.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_process_event(id window_id, event *event_s) (out i32) {
    panicIfNot(is_valid_window(id), "window_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_resize(id window_id) () {
    panicIfNot(is_valid_window(id), "window_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_render(id window_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_window(id), "window_render : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// KEYBOARD
//-----------------------------------------------------------------------------
var g_keyboards[] keyboard_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_id struct {
    base ControlId
    keyboard i32
}

type mapping_s struct {
    low []str
    high []str
    codes []i32
    keys []i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_s struct {
    id keyboard_id
    keys []LabelId
    caps bool
    dvorak mapping_s
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_id_(base ControlId, keyboard i32) (out keyboard_id) {
    out.base = base
    out.keyboard = keyboard
    panicIfNot(is_valid_keyboard(out), "keyboard_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_keyboard(id keyboard_id) (out bool) {
    out = id.keyboard >= 0 && id.keyboard < len(g_keyboards) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_keyboard(name str) (out keyboard_id) {
    out.keyboard = len(g_keyboards)
    out.base = controlCreate(name, GUI_KEYBOARD, out.keyboard)

    var keyboard keyboard_s
    keyboard.id = out

    keyboard.dvorak.low = []str{"<", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "[", "]",
                                " ", "'", ",", ".", "p", "y", "f", "g", "c", "r", "l", "/", "=",
                                " ", "a", "o", "e", "u", "i", "d", "h", "t", "n", "s", "-", "\\",
                                "`", ";", "q", "j", "k", "x", "b", "m", "w", "v", "z", " ", " " }

    keyboard.dvorak.high = []str { ">", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "{", "}",
                                   " ", "X", "<", ">", "P", "Y", "F", "G", "C", "R", "L", "?", "+",
                                   " ", "A", "O", "E", "U", "I", "D", "H", "T", "N", "S", "_", "|",
                                   "~", ":", "Q", "J", "K", "X", "B", "M", "W", "V", "Z", " ", " " }

    keyboard.dvorak.codes = []i32 { 940, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
                                    -1, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
                                    -1, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 51,
                                    49, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1 }

    keyboard.dvorak.keys= []i32 {161, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61,
                                    -1, 81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 91, 93,
                                    -1, 65, 83, 68, 70, 71, 72, 74, 75, 76, 59, 39, 92,
                                    96, 90, 88, 67, 86, 66, 78, 77, 44, 46, 47, -1, -1 }


    var count i32 = len(keyboard.dvorak.low)
    for i := 0; i < count; i++ {
        var label LabelId = LabelCreate(sprintf("key_%d", i))
        ControlAddChild(out.base, label.base)
        ControlSetSkin(label.base, g_blueSkin)
        //ControlSetFocusable(label.base, 1)
        //ControlSetAutoscale(label.base, AUTOSCALE)
        LabelSetSize(label, g_fontSizeHeader)
        LabelSetAlign(label, ALIGN_CENTER)
        LabelSetFont(label, g_boldFont)
        LabelSetColor(label, g_white)
        keyboard.keys = append(keyboard.keys, label)
    }

    ControlSetPadding(out.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
    g_keyboards = append(g_keyboards, keyboard)

    panicIfNot(is_valid_keyboard(out), "create_keyboard : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_get_key_index(id keyboard_id, key i32) (index i32) {
    panicIfNot(is_valid_keyboard(id), "keyboard_process_event : invalid id")

    index = -1
    var keys []i32 = g_keyboards[id.keyboard].dvorak.keys
    var count i32 = len(keys)
    for i := 0; i < count; i++ {
        if keys[i] == key {
            index = i
            i = count
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_process_event(id keyboard_id, event *event_s) (out i32) {
    panicIfNot(is_valid_keyboard(id), "keyboard_process_event : invalid id")
    out = control_process_event(id.base, event)

    var action i32 = (*event).keyboard.action
    var key i32 = (*event).keyboard.key
    var mods i32 = (*event).keyboard.mods

    if key == KEYCODE_SHIFT{
        if action == KEY_PRESS {
            g_keyboards[id.keyboard].caps = true
            out = EVENT_CONSUMED
        } else if action == KEY_RELEASE {
            g_keyboards[id.keyboard].caps = false
            //out = EVENT_CONSUMED
        }
    } else {
        var selected i32 = -1
        if action == KEY_PRESS {
            selected = 1
        } else if action == KEY_RELEASE {
            selected = 0
        }

        if selected == 0 || selected == 1 {
            var index i32 = keyboard_get_key_index(id, key)
            if index >= 0 && index < len(g_keyboards[id.keyboard].keys) {
                var label LabelId = g_keyboards[id.keyboard].keys[index]
                ControlSetSelected(label.base, selected)
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_resize(id keyboard_id) () {
    panicIfNot(is_valid_keyboard(id), "keyboard_resize : invalid id")

    var rowCount i32 = 13
    var lineCount i32 = 4

    var paddingX f32 = 5.0
    var paddingY f32 = 5.0

    var fRowCount f32 = i32.f32(rowCount)
    var fLineCount f32 = i32.f32(lineCount)

    var keyWidth f32 = 50.0
    var keyHeight f32 = 50.0

    var height f32 = fLineCount * keyHeight + (fLineCount + 1.0) * paddingX
    var width f32 = fRowCount * keyWidth + (fRowCount + 1.0) * paddingY

    var w f32 = width
    var h f32 = height
    var x f32 = 0.0
    var y f32 = 0.0

    var mapping []str = g_keyboards[id.keyboard].dvorak.low
    if g_keyboards[id.keyboard].caps {
        mapping = g_keyboards[id.keyboard].dvorak.high
    }

    //var count i32 = 0
    var i i32 = 0
    var j i32 = 0
    for i = 0; i < rowCount; i = i + 1 {
        for j = 0; j < lineCount; j = j + 1 {
            var kx f32 = paddingX + x + i32.f32(i) * (paddingX + keyWidth)
            var ky f32 = paddingY + y + i32.f32(j) * (paddingY + keyHeight)
            var kw f32 = keyWidth
            var kh f32 = keyHeight

            var l i32 = (lineCount - 1 - j) * rowCount + i
            var label LabelId = g_keyboards[id.keyboard].keys[l]

            ControlSetPosition(label.base, mat.v2_(kx, ky))
            ControlSetSize(label.base, mat.v2_(kw, kh))
            LabelSetText(label, mapping[l])
            //gfx.MeshAppendQuad(g_opaqueVertexColoredTriangles, mat.v4_(kx, ky, kw, kh), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_blue)
            //gfx.append_text(g_alphaTexturedTriangles, g_skycoinFontTexture, "skycoin", kx, ky, gui.g_lightBlue, "A", false, false)
            //gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(kx, ky, kw, kh), gui.g_blue, gui.g_blue, gui.g_blue, gui.g_blue)
            //count = count + 1
        }
    }

    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_render(id keyboard_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_keyboard(id), "keyboard_render : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// PARTITION
//-----------------------------------------------------------------------------
var g_partitions [] partition_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_id struct {
    base ControlId
    partition i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_s struct {
    id partition_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_id_(base ControlId, partition i32) (out partition_id) {
    out.base = base
    out.partition = partition
    panicIfNot(is_valid_partition(out), "partition_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_partition(id partition_id) (out bool) {
    out = id.partition >= 0 && id.partition < len(g_partitions) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_partition(name str) (out partition_id) {
    out.partition = len(g_partitions)
    out.base = controlCreate(name, GUI_PARTITION, out.partition)

    var partition partition_s
    partition.id = out

    g_partitions = append(g_partitions, partition)
    panicIfNot(is_valid_partition(out), "create_partition : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_process_event(id partition_id, event *event_s) (out i32) {
    panicIfNot(is_valid_partition(id), "partition_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_resize(id partition_id) () {
    panicIfNot(is_valid_partition(id), "partition_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_render(id partition_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_partition(id), "partition_render : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// GRAPH
//-----------------------------------------------------------------------------
type graph_id struct {
    base ControlId
    graph i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type graph_s struct {
    id graph_id
    unit mat.v2
    scale mat.v2
    offset mat.v2
    expX i32
    expY i32
    coord mat.v2
    labels [] LabelId
    labelCount i32
    horz [] graph_line_s
    vert [] graph_line_s
    graphClips mat.v4
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_id_(base ControlId, graph i32) (out graph_id) {
    out.base = base
    out.graph = graph
    panicIfNot(is_valid_graph(out), "graph_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_graph(id graph_id) (out bool) {
    out = id.graph >= 0 && id.graph < len(g_graphs) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_graphs []graph_s

type graph_line_s struct {
    color mat.v4
    bounds mat.v4
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_create(name str) (out graph_id) {
    out.base = controlCreate(name, GUI_GRAPH, out.graph)
    ControlSetFocusable(out.base, 1)

    out.graph = len(g_graphs)

    var graph graph_s
    graph.id = out
    graph.unit = mat.v2_(50.0, 50.0)
    graph.scale = mat.v2_(1.0, 1.0)
    graph.offset = mat.v2_(0.0, 0.0)
    graph.expX = 0
    graph.expY = 0
    graph.labelCount = 0

    g_graphs = append(g_graphs, graph)
    panicIfNot(is_valid_graph(out), "graph_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_get_label(id graph_id) (label LabelId) {
    panicIfNot(is_valid_graph(id), "graph_get_label : invalid id")
    var size i32 = len(g_graphs[id.graph].labels)
    var count i32 = g_graphs[id.graph].labelCount
    if count < size {
        var l LabelId = g_graphs[id.graph].labels[count] // ##0 memory garbage in count if assigning the out value
        label = l
    } else {
        label = LabelCreate(sprintf("graphLabel_%d", count))
        g_graphs[id.graph].labels = append(g_graphs[id.graph].labels, label)
    }
    g_graphs[id.graph].labelCount = count + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_process_event(id graph_id, event *event_s) (out i32) {
    panicIfNot(is_valid_graph(id), "graph_process_event : invalid id")
    //ControlPrint("graph_process_event : ", id.base, false)

    out = control_process_event(id.base, event)
    if (out == EVENT_UNUSED) {
        var controlIndex i32 = id.base.control
        var focused i32 = g_controls[controlIndex].focused
        var childFocused i32 = g_controls[controlIndex].childFocused
        if (focused > 0 || childFocused > 0) {
            var key i32 = ((*event).keyboard).key
            var action i32 = ((*event).keyboard).action
            var mods i32 = ((*event).keyboard).mods
            var graphIndex i32 = id.graph
            var unit mat.v2 = g_graphs[graphIndex].unit
            var scale mat.v2 = g_graphs[graphIndex].scale
            var offset mat.v2 = g_graphs[graphIndex].offset
            if (mods == MOD_CTRL) {
                if (action == KEY_PRESS ||
                    action == KEY_REPEAT) {
                    if (key == KEYCODE_LEFT) {
                        out = EVENT_CONSUMED
                        scale.x = scale.x * 0.9
                    } else if (key == KEYCODE_RIGHT) {
                        out = EVENT_CONSUMED
                        scale.x = scale.x * 1.1
                    } else if (key == KEYCODE_DOWN) {
                        out = EVENT_CONSUMED
                        scale.y = scale.y * 0.9
                    } else if (key == KEYCODE_UP) {
                        out = EVENT_CONSUMED
                        scale.y = scale.y * 1.1
                    }
                    if (scale.x > 1.0) {
                        scale.x = 0.1
                        g_graphs[graphIndex].expX = g_graphs[graphIndex].expX + 1
                    } else if (scale.x < 0.1) {
                        scale.x = 1.0
                        g_graphs[graphIndex].expX = g_graphs[graphIndex].expX - 1
                    }

                    if (scale.y > 1.0) {
                        scale.y = 0.1
                        g_graphs[graphIndex].expY = g_graphs[graphIndex].expY + 1
                    } else if (scale.y < 0.1) {
                        scale.y = 1.0
                        g_graphs[graphIndex].expY = g_graphs[graphIndex].expY - 1
                    }
                    g_graphs[graphIndex].scale = scale
                    g_graphs[graphIndex].unit = unit
                }
            } else if (mods == MOD_NONE) {
                if (action == KEY_PRESS ||
                        action == KEY_REPEAT) {
                    if (key == KEYCODE_LEFT) {
                        out = EVENT_CONSUMED
                        offset.x = offset.x - unit.x * 0.1 * scale.x
                    } else if (key == KEYCODE_RIGHT) {
                        out = EVENT_CONSUMED
                        offset.x = offset.x + unit.x * 0.1 * scale.x
                    } else if (key == KEYCODE_DOWN) {
                        out = EVENT_CONSUMED
                        offset.y = offset.y - unit.y * 0.1 * scale.y
                    } else if (key == KEYCODE_UP) {
                        out = EVENT_CONSUMED
                        offset.y = offset.y + unit.y * 0.1 * scale.y
                    }
                    g_graphs[graphIndex].offset = offset
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_resize(id graph_id) () {
    panicIfNot(is_valid_graph(id), "graph_resize : invalid id")
    ControlClearChildren(id.base)
    control_resize(id.base)

    var graphIndex i32 = id.graph
    g_graphs[graphIndex].coord = mat.v2_(32.0, 32.0)

    var controlIndex i32 = id.base.control

    g_graphs[graphIndex].horz = resize(g_graphs[graphIndex].horz, 0)
    g_graphs[graphIndex].vert = resize(g_graphs[graphIndex].vert, 0)
    g_graphs[graphIndex].labelCount = 0

    var graphIndex i32 = id.graph

    var offset mat.v2 = g_graphs[graphIndex].offset
    var unit mat.v2 = g_graphs[graphIndex].unit
    var scale mat.v2 = g_graphs[graphIndex].scale

    var controlIndex i32 = id.base.control

    var width f32 = g_controls[controlIndex].size.x
    var height f32 = g_controls[controlIndex].size.y

    var size mat.v2 = g_controls[controlIndex].size
    var position mat.v2 = g_controls[controlIndex].renderPosition

    var coord mat.v2 = g_graphs[graphIndex].coord

    var stepX f32 = unit.x * scale.x
    var stepY f32 = unit.y * scale.y

    var i i32 = 0
    var ix i32 = 0
    var iy i32 = 0

    var offsetX f32 = offset.x
    if (offsetX > 0) {
        for (offsetX > 0) {
            offsetX = offsetX - stepX
            ix = ix - 1
        }
    } else if (offsetX < 0) {
        for ((offsetX + stepX) < 0) {
            offsetX = offsetX + stepX
            ix = ix + 1
        }
    }

    var offsetY f32 = offset.y
    if (offsetY > 0) {
        for (offsetY > 0) {
            offsetY = offsetY - stepY
            iy = iy - 1
        }
    } else if (offsetY < 0) {
        for ((offsetY + stepY) < 0) {
            offsetY = offsetY + stepY
            iy = iy + 1
        }
    }

    var graphPosition mat.v2
    graphPosition.x = position.x + offsetX + coord.x
    graphPosition.y = position.y + offsetY + coord.y

    var endX f32 = graphPosition.x + size.x - offsetX - coord.x
    var endY f32 = graphPosition.y + size.y - offsetY - coord.y

    g_graphs[graphIndex].graphClips = mat.v4_(graphPosition.x, graphPosition.y, size.x - coord.x, size.y - coord.y)

    var graphLine graph_line_s
    var font font_id

    i = 0
    var labelX f32 = coord.x + offsetX //- stepX / 2.0
    var x f32 = graphPosition.x
    for (x < endX) {
        var color mat.v4 = g_gray_2

        var labelBounds mat.v4 = mat.v4_(labelX, 0.0, stepX, coord.y)
        var big f32 = labelX - 2.0 * stepX
        var bigW f32 = stepX * 4.0
        if ((ix % 100) == 0) {
            color = g_gray_3
            font = g_boldFont
            labelBounds = mat.v4_(big, 0.0, bigW, coord.y)
        } else if ((ix % 10) == 0) {
            color = mat.v4_mix(g_gray_2, g_gray_3, scale.x)
            font = g_boldFont
            labelBounds = mat.v4_(big, 0.0, bigW, coord.y)
        } else {
            color = mat.v4_mix(g_gray_0, g_gray_2, scale.x)
            font = g_regularFont
            var fTmp f32 = labelX - stepX / 2.0
            labelBounds = mat.v4_(fTmp, 0.0, stepX, coord.y)
        }

        graphLine.color = color
        graphLine.bounds = mat.v4_(x, graphPosition.y, x, endY)
        g_graphs[graphIndex].horz = append(g_graphs[graphIndex].horz, graphLine)

        var label LabelId = graph_get_label(id)
        ControlAddChild(id.base, label.base)
        ControlSetBounds(label.base, labelBounds)
        ControlSetAutoscale(label.base, AUTOSCALE)
        LabelSetFont(label, g_regularFont)
        LabelSetColor(label, color)
        LabelSetText(label, "0")
        LabelSetAlign(label, ALIGN_CENTER)
        LabelSetSize(label, 10)
        LabelResize(label)
        ControlSetBounds(label.base, labelBounds)

        labelX = labelX + stepX
        x = x + stepX
        ix = ix + 1
        i = i + 1
    }

    i = 0
    var labelY f32 = coord.y + offsetY// - stepY / 2.0
    var y f32 = graphPosition.y
    for (y < endY) {
        var color mat.v4 = g_gray_2
        //var font font_id

        var fTmp f32 = labelY - stepY / 2.0
        var labelBounds mat.v4 = mat.v4_(0.0, fTmp, coord.x, coord.y)
        //var big f32 = labelY - 2.0 * stepY
        //var bigW f32 = stepY * 4.0
        if ((iy % 100) == 0) {
            color = g_gray_3
            font = g_boldFont
            var fTmp0 f32 = labelY - coord.y / 2.0
            labelBounds = mat.v4_(0.0, fTmp0, coord.x, coord.y)
        } else if ((iy % 10) == 0) {
            color = mat.v4_mix(g_gray_2, g_gray_3, scale.y)
            font = g_boldFont
            var fTmp0 f32 = labelY - coord.y / 2.0
            labelBounds = mat.v4_(0.0, fTmp0, coord.x, coord.y)
        } else {
            color = mat.v4_mix(g_gray_0, g_gray_2, scale.y)
            font = g_regularFont
            labelBounds = mat.v4_(0.0, fTmp, coord.x, stepY)
        }

        graphLine.color = color
        graphLine.bounds = mat.v4_(graphPosition.x, y, endX, y)
        g_graphs[graphIndex].vert = append(g_graphs[graphIndex].vert, graphLine)

        var label LabelId = graph_get_label(id)
        ControlAddChild(id.base, label.base)
        ControlSetBounds(label.base, labelBounds)
        ControlSetAutoscale(label.base, AUTOSCALE)
        LabelSetFont(label, g_regularFont)
        LabelSetColor(label, color)
        LabelSetText(label, "0")
        LabelSetAlign(label, ALIGN_CENTER)
        LabelSetSize(label, 50)
        LabelResize(label)
        ControlSetBounds(label.base, labelBounds)

        labelY = labelY + stepY
        y = y + stepY
        iy = iy + 1
        i = i + 1
    }

    //control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_render(id graph_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_graph(id), "graph_render : invalid id")
    control_render(id.base, clip, stack)

    var controlIndex i32 = id.base.control
    var graphIndex i32 = id.graph

    var renderBounds mat.v4 = mat.v4_v2v2(g_controls[controlIndex].renderPosition, g_controls[controlIndex].size)
    //ControlPrint("graph_render : renderBounds ", id.base, false)
    //  printf("renderBounds %f, %f, %f, %f\n", renderBounds.x, renderBounds.y, renderBounds.z, renderBounds.w)
    var renderClips mat.v4 = gfx.push_scissor(g_controls[controlIndex].name, renderBounds)
    //ControlPrint("graph_render : graphClips ", id.base, false)
    var graphClips mat.v4 = g_graphs[graphIndex].graphClips
    //  printf("graphClips %f, %f, %f, %f\n", graphClips.x, graphClips.y, graphClips.z, graphClips.w)
    renderClips = gfx.push_scissor(g_controls[controlIndex].name, graphClips)

    var i i32 = 0
    var horzCount i32 = len(g_graphs[graphIndex].horz)
    for i = 0; i < horzCount; i = i + 1 {
        var bounds mat.v4 = g_graphs[graphIndex].horz[i].bounds
        var color mat.v4 = g_graphs[graphIndex].horz[i].color
        gfx.MeshAppendLine(g_opaqueVertexColoredLines, bounds, color, renderClips, compute_depth(stack))
    }

    var vertCount i32 = len(g_graphs[graphIndex].vert)
    for i = 0; i < vertCount; i = i + 1 {
        var bounds mat.v4 = g_graphs[graphIndex].vert[i].bounds
        var color mat.v4 = g_graphs[graphIndex].vert[i].color
        /*if (i == 3) {
          color = mat.v4_(0.0, 1.0, 0.0, 1.0)
          bounds.y = bounds.y + 0.01
          bounds.w = bounds.w + 0.01
          }*/
        //        printf("II %d, COLOR %f, %f, %f, %f, BOUNDS %f, %f, %f, %f\n",
        //          i, color.x, color.y, color.z, color.w, bounds.x, bounds.y, bounds.z, bounds.w)
        gfx.MeshAppendLine(g_opaqueVertexColoredLines, bounds, color, renderClips, compute_depth(stack))
    }
    gfx.pop_scissor()
    gfx.pop_scissor()
}

//-----------------------------------------------------------------------------
// LIST
//-----------------------------------------------------------------------------
type list_id struct {
    base ControlId
    list i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type list_s struct {
    id list_id

    header ControlId
    columnCount i32
    scroller scroller_id
    lines ControlId
    lineCount i32
    offset mat.v2
    selectedLine i32
    selectedItem i32
    previousSelectedLine i32
    previousSelectedItem i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_id_(base ControlId, list i32) (out list_id) {
    out.base = base
    out.list = list
    panicIfNot(is_valid_list(out), "list_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_list(id list_id) (out bool) {
    out = id.list >= 0 && id.list < len(g_lists) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_lists[] list_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_create(name str) (out list_id) {
    out.list = len(g_lists)
    out.base = controlCreate(name, GUI_LIST, out.list)

    var list list_s
    list.id = out

    var controlIndex i32 = out.base.control
    //ControlSetPadding(out.base, mat.v4_(0.01, 0.01, 0.01, 0.01))

    var header ControlId = ControlCreate("header")
    ControlAddChild(out.base, header)
    ControlSetDock(header, DOCK_TOP)
    //ControlSetSize(header, mat.v2_(0.0, 28.0))
    ControlSetAutosize(header, AUTOSIZE_Y)
    ControlSetSkin(header, g_blackSkin)
    list.header = header

    {
        var scroller scroller_id = scroller_create("scroller")
        ControlAddChild(out.base, scroller.base)
        ControlSetDock(scroller.base, DOCK_FILL)
        //ControlSetAutosize(scroller.base, AUTOSIZE_Y)

        var lines ControlId = ControlCreate("lines")
        //ControlSetDock(lines, DOCK_FILL)
        ControlSetAutosize(lines, AUTOSIZE_Y)
        ControlSetSkin(lines, g_blackSkin)
        list.lines = lines

        scroller_set_containee(scroller, lines)
        list.scroller = scroller
    }

    list.columnCount = 0
    list.lineCount = 0
    list.selectedItem = -1
    list.selectedLine = -1
    list.previousSelectedItem = -1
    list.previousSelectedLine = -1
    g_lists = append(g_lists, list)
    panicIfNot(is_valid_list(out), "list_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_add_column(id list_id, name str, color mat.v4, size i32, skin skin_id) {
    panicIfNot(is_valid_list(id), "list_add_column : invalid id")

    var listIndex i32 = id.list
    var columnCount i32 = g_lists[listIndex].columnCount
    var column LabelId = LabelCreate(sprintf("column_%d", columnCount))
    ControlSetDock(column.base, DOCK_LEFT)
    //ControlSetSize(column.base, mat.v2_(0.0, 26.0))
    ControlSetFocusable(column.base, 1)
    ControlSetAutosize(column.base, AUTOSIZE_Y)
    ControlSetPadding(column.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    if (is_valid_skin(skin)) {
        ControlSetSkin(column.base, skin)
    }
    LabelSetFont(column, g_boldFont)
    LabelSetText(column, name)
    LabelSetSize(column, size)
    LabelSetColor(column, color)
    LabelSetAlign(column, ALIGN_CENTER)

    //ControlPrint("list_add_column : ", column.base, false)
    g_lists[listIndex].columnCount = columnCount + 1
    var header ControlId = g_lists[listIndex].header
    ControlAddChild(header, column.base)
    //printf("childCount %d\n", g_controls[header.control].childCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_clear_lines(id list_id) {
    panicIfNot(is_valid_list(id), "list_clear_lines : invalid id")

    var lines ControlId = g_lists[id.list].lines
    ControlClearChildren(lines)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_add_line(id list_id, skin skin_id) (out ControlId) {
    panicIfNot(is_valid_list(id), "list_add_line")
    var listIndex i32 = id.list
    var lineCount i32 = g_lists[listIndex].lineCount
    var line ControlId = ControlCreate(sprintf("line_%d", lineCount))

    var lines ControlId = g_lists[id.list].lines
    ControlSetDock(line, DOCK_TOP)
    ControlSetSize(line, mat.v2_(0.0, 0.0))
    ControlSetAutosize(line, AUTOSIZE_Y)
    ControlAddChild(lines, line)
    if (is_valid_skin(skin)) {
        ControlSetSkin(line, skin)
    }
    //ControlSetFocusable(line, 1)
    g_lists[listIndex].lineCount = lineCount + 1
    out = line
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_line_add_label(id ControlId, text str, align i32, color mat.v4, size i32, skin skin_id) {
    panicIfNot(IsValidControl(id), "list_line_add_label : invalid id")

    var lineName str = g_controls[id.control].name
    var itemCount i32 = len(g_controls[id.control].children)
    var itemName str = sprintf("%s_item_%d", lineName, itemCount)
    var label LabelId = LabelCreate(itemName)

    ControlAddChild(id, label.base)
    ControlSetDock(label.base, DOCK_LEFT)
    if (is_valid_skin(skin)) {
        ControlSetSkin(label.base, skin)
    }
    ControlSetPadding(label.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    ControlSetFocusable(label.base, 1)
    ControlSetAutosize(label.base, AUTOSIZE_Y)
    LabelSetFont(label, g_regularFont)
    LabelSetText(label, text)
    LabelSetSize(label, size)
    LabelSetColor(label, color)
    LabelSetAlign(label, align)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_line_add_picture(id ControlId, align i32, animation animation_id) {
    panicIfNot(IsValidControl(id), "list_line_add_picture : invalid id")

    var lineName str = g_controls[id.control].name
    var itemCount i32 = len(g_controls[id.control].children)
    var itemName str = sprintf("%s_item_%d", lineName, itemCount)
    var label PictureId = PictureCreate(itemName)

    ControlAddChild(id, label.base)
    ControlSetDock(label.base, DOCK_LEFT)
    //ControlSetSkin(label.base, g_grayFocusedSkin)
    ControlSetPadding(label.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    ControlSetSize(label.base, mat.v2_(32.0, 32.0))
    ControlSetFocusable(label.base, 1)
    ControlSetAutoscale(label.base, AUTOSCALE)
    //ControlSetAlign(label, align)
    PictureSetAlign(label, align)
    PictureSetAnimation(label, animation)
    /*LabelSetFont(label, g_regularFont)
    LabelSetText(label, text)
    LabelSetSize(label, size)
    LabelSetColor(label, color)
    LabelSetAlign(label, align)*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_child_focused(id list_id, child ControlId, value i32) {
    panicIfNot(is_valid_list(id), "list_child_focus : invalid id")
    panicIfNot(IsValidControl(child), "list_child_focus : invalid child id")
    if (value > 0) {

        var header ControlId = g_lists[id.list].header
        var panel ControlId = g_lists[id.list].lines
        var panelFocused  i32 = g_controls[panel.control].focused
        var panelChildFocused i32 = g_controls[panel.control].childFocused
        var headerFocused i32 = g_controls[header.control].focused
        var headerChildFocused i32 = g_controls[header.control].childFocused

        if (panelFocused > 0 || panelChildFocused > 0 || headerFocused > 0 || headerChildFocused > 0) {

            var headerVisible i32 = g_controls[header.control].visible
            var headerOffset i32 = 0
            if (headerVisible <= 0) {
                headerOffset = 1
            }

            var line ControlId = g_controls[child].parent

            var previousSelectedLine i32 = g_lists[id.list].previousSelectedLine
            var previousSelectedItem i32 = g_lists[id.list].previousSelectedItem
            var selectedLine i32 = g_lists[id.list].selectedLine
            var selectedItem i32 = g_lists[id.list].selectedItem

            g_lists[id.list].previousSelectedLine = selectedLine
            g_lists[id.list].previousSelectedItem = selectedItem

            var lineFocusIndex i32 = g_controls[line.control].focusIndex
            var itemFocusIndex i32 = g_controls[child.control].focusIndex

            if (line.control != header.control) {
                lineFocusIndex = lineFocusIndex + headerOffset
            }

            g_lists[id.list].selectedLine = lineFocusIndex
            g_lists[id.list].selectedItem = itemFocusIndex

            if (previousSelectedLine != selectedLine &&
                previousSelectedItem != selectedItem) {
                ControlPrint("CHILD_FOCUSED : ", line, false)
            }
        }

/*        var selectedLine i32 = g_lists[id.list].selectedLine
        var selectedItem i32 = g_lists[id.list].selectedItem


            //ControlPrint("list_child_focused panel : ", panel, false)
            var columnCount i32 = g_controls[header.control].childCount
            var lineCount i32 = g_controls[panel.control].childCount

            if (columnCount > 0) {

                if (selectedLine < 0) {
                    selectedLine = headerOffset
                }

                if (selectedItem < 0) {
                    selectedItem = 0
                }

                var selectedLineId ControlId
                if (selectedLine > headerOffset) {
                    var currentLine i32 = selectedLine - 1
                    selectedLineId = g_controls[panel.control].children[currentLine]
                } else {
                    selectedLineId = header
                }
                var previousSelectedLine i32 = g_lists[id.list].previousSelectedLine
                var previousSelectedItem i32 = g_lists[id.list].previousSelectedItem
                var selectedItemId ControlId = g_controls[selectedLineId.control].children[selectedItem]
                g_lists[id.list].previousSelectedLine = g_lists[id.list].selectedLine
                g_lists[id.list].previousSelectedItem = g_lists[id.list].selectedItem
                g_lists[id.list].selectedLine = selectedLine
                g_lists[id.list].selectedItem = selectedItem

                g_controls[selectedLineId.control].selected = 1
                g_controls[selectedItemId.control].selected = 1
                if (selectedItemId.control != child.control) {
                    ControlPrint("list_child_focused : force_focus SELECTED : ", selectedItemId, false)
                    ControlPrint("list_child_focused : force_focus CHILD : ", child, false)
                    force_focus(selectedItemId)
                }
            }
        }*/
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_process_event(id list_id, event *event_s) (out i32) {
    panicIfNot(is_valid_list(id), "list_process_event : invalid id")
    out = control_process_event(id.base, event)


    if (out == EVENT_UNUSED) {
        var index i32 = id.base.control
        var columns ControlId = g_lists[id.list].header
        var columnsIndex i32 = columns.control
        var headerFocused i32 = g_controls[columnsIndex].childFocused
        var headerVisible i32 = g_controls[columnsIndex].visible
        var lines ControlId = g_lists[id.list].lines
        var linesIndex i32 = lines.control
        var focused i32 = g_controls[linesIndex].childFocused
        var mods i32 = ((*event).keyboard).mods
        var action i32 = ((*event).keyboard).action
        var lineCount i32 = len(g_controls[linesIndex].children)
        var itemCount i32 = len(g_controls[columnsIndex].children)
        if (lineCount > 0) {
            if ((headerFocused > 0 || focused > 0) && action == KEY_PRESS) {
                var key i32 = ((*event).keyboard).key
                var action i32 = ((*event).keyboard).action
                var selectedLine i32 = g_lists[id.list].selectedLine
                var selectedItem i32 = g_lists[id.list].selectedItem
     
                var headerOffset i32 = 0
                if (headerVisible <= 0) {
                    headerOffset = 1
                }
                if (key == KEYCODE_LEFT) {
                    selectedItem = selectedItem - 1
                    if (selectedItem < 0) {
                        selectedItem = itemCount - 1
                    }
                    out = EVENT_CONSUMED
                } else if (key == KEYCODE_DOWN) {
                    selectedLine = selectedLine + 1
                    if (selectedLine > lineCount) {
                        if (mods == MOD_CTRL) {
                            selectedLine = lineCount
                            out = EVENT_UNUSED
                            //printf("EVENT_UNUSED\n")
                        }else {
                            selectedLine = headerOffset
                            out = EVENT_CONSUMED
                        }
                   }
                } else if (key == KEYCODE_RIGHT) {
                    selectedItem = selectedItem + 1
                    if (selectedItem >= itemCount) {
                        selectedItem = 0
                    }
                    out = EVENT_CONSUMED
                } else if (key == KEYCODE_UP) {
                    selectedLine = selectedLine - 1
                    if (selectedLine < headerOffset) {
                        if (mods == MOD_CTRL) {
                            selectedLine = selectedLine + 1
                            out = EVENT_UNUSED
                            //printf("EVENT_UNUSED\n")
                        } else {
                            selectedLine = lineCount
                            out = EVENT_CONSUMED
                        }
                    }
                } else if (key == KEYCODE_TAB) {
                    if (mods == MOD_SHIFT) {
                        if (selectedItem > 0) {
                            selectedItem = selectedItem - 1
                            out = EVENT_CONSUMED
                        } else {
                            if (selectedLine > headerOffset) {
                                selectedLine = selectedLine - 1
                                selectedItem = itemCount - 1
                                out = EVENT_CONSUMED
                            } else {
                                out = EVENT_UNUSED
                            }
                        }
                    } else {
                        if ((selectedItem + 1) < itemCount) {
                            selectedItem = selectedItem + 1
                            out = EVENT_CONSUMED
                        } else {
                            if ((selectedLine + 1) <= lineCount) {
                                selectedLine = selectedLine + 1
                                selectedItem = 0
                                out = EVENT_CONSUMED
                            } else {
                                out = EVENT_UNUSED
                            }
                        }
                    }
                }

                g_lists[id.list].selectedLine = selectedLine
                g_lists[id.list].selectedItem = selectedItem
                //printf("SELECTED LINE %d, ITEM %d\n", selectedLine, selectedItem)
            }
        } else {
            g_lists[id.list].selectedLine = -1
            g_lists[id.list].selectedItem = -1
        }
    }
    //printf("list_process_event : OUT %d\n", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_resize(id list_id) () {
    panicIfNot(is_valid_list(id), "resize_list : invalid id")

    var listIndex i32 = id.list
    var header ControlId = g_lists[listIndex].header
    var headerIndex i32 = header.control

    var scroller scroller_id = g_lists[listIndex].scroller
    var scrollerContainer ControlId = g_scrollers[scroller.scroller].container
    var scrollerPanel ControlId = g_scrollers[scroller.scroller].panel

    var lines ControlId = g_lists[listIndex].lines
    var linesIndex i32 = lines.control
    var columnCount i32 = len(g_controls[headerIndex].children)
    var lineCount i32 = len(g_controls[linesIndex].children)
    var i i32 = 0

    /*if (id.base.control == 36) {
        printf("--------------------------------> list_resize\n")
        ControlPrint("list_resize : ", id.base, false)
        ControlPrint("list_resize : LINES ", lines, false)
        printf("columnCount %d, lineCount %d, listIndex %d, headerIndex %d, linesIndex %d\n", columnCount, lineCount, listIndex, headerIndex, linesIndex)
    }*/

    var containerWidth f32 = g_controls[scrollerContainer].size.x
    var scrollerWidth f32 = g_controls[scroller.base.control].size.x

    var lineWidth f32 = 0.0
    for i = 0; i < columnCount; i = i + 1 {
    var maxWidth f32 = 0.0
        var column ControlId = g_controls[headerIndex].children[i]
        /*if (id.base.control == 36) {
            ControlPrint("list_resize : column ", column, false)
        }*/
        var columnIndex i32 = column.control
        g_controls[column.control].selected = 0

        var width f32
        var height f32
        width, height = control_measure(column)
        //printf("COLUMN_MEASURE %f, %f\n", width, height)
        maxWidth = mat.max(maxWidth, width)
        var k i32 = 0
        for k = 0; k < lineCount; k = k + 1 {
            var line ControlId = g_controls[linesIndex].children[k]
            var lineIndex i32 = line.control
            /*if (id.base.control == 36) {
                ControlPrint("list_resize : line ", line, false)
            }*/

            var item ControlId = g_controls[lineIndex].children[i]
            //ControlPrint("list_resize : item ", item, false)
            var itemIndex i32 = item.control

            width, height = control_measure(item)
            //printf("ITEM_MEASURE %f, %f\n", width, height)
            maxWidth = mat.max(maxWidth, width)
            //printf("WIDTH %f, MAX_WIDTH %f\n", width, maxWidth)
        }
        //printf("MAX_WIDTH %f\n", maxWidth)
        g_controls[columnIndex].size.x = maxWidth
        if ((i + 1) == columnCount) {
            ControlSetDock(column, DOCK_FILL)
            g_controls[columnIndex].size.x = mat.max(maxWidth, scrollerWidth - lineWidth)
        }

        //ControlPrint("column : ", column, false)
        for k = 0; k < lineCount; k = k + 1 {
            var line ControlId = g_controls[linesIndex].children[k]
            var lineIndex i32 = line.control
            if (i == 0) {
                g_controls[lineIndex].size.x = 0.0
            }
            var currentWidth f32 = g_controls[lineIndex].size.x
            g_controls[lineIndex].size.x = currentWidth + maxWidth
            //printf("i %d, lineIndex %d, line %d, width %f\n", i, lineIndex, k, width)
            //ControlPrint("line : ", line, false)
            var item ControlId = g_controls[lineIndex].children[i]
            var itemIndex i32 = item.control

            g_controls[itemIndex].size.x = maxWidth
            g_controls[itemIndex].selected = 0
            g_controls[lineIndex].selected = 0
            if ((i + 1) == columnCount) {
                ControlSetDock(item, DOCK_FILL)
                g_controls[itemIndex].size.x = mat.max(maxWidth, containerWidth - lineWidth)
            }

            /*var focusedItem i32 = g_controls[itemIndex].focused
            if (focusedItem > 0) {
                g_lists[listIndex].selectedLine = k
                g_lists[listIndex].selectedItem = i
            }*/
            //ControlPrint("item : ", item, false)
        }
        lineWidth = lineWidth + maxWidth
    }

    var headerVisible i32 = g_controls[headerIndex].visible
    var headerOffset i32 = 0
    if (headerVisible <= 0) {
        headerOffset = 1
    }
/*    if (lineCount > 0 && columnCount > 0) {

        var selectedLine i32 = g_lists[listIndex].selectedLine
        if (selectedLine < 0) {
            selectedLine = headerOffset
        }

        var selectedItem i32 = g_lists[listIndex].selectedItem
        if (selectedItem < 0) {
            selectedItem = 0
        }

        var selectedLineId ControlId
        if (selectedLine > headerOffset) {
            var currentLine i32 = selectedLine - 1
            selectedLineId = g_controls[linesIndex].children[currentLine]
        } else {
            selectedLineId = header
        }
        var selectedItemId ControlId = g_controls[selectedLineId.control].children[selectedItem]

        var previousSelectedLine i32 = g_lists[listIndex].previousSelectedLine
        var previousSelectedItem i32 = g_lists[listIndex].previousSelectedItem
        if (selectedLine != previousSelectedLine || selectedItem != previousSelectedItem) {
            printf("selectedLine child, %d, index %d, selectedItem child %d, index %d\n", selectedLineId.control, selectedLine, selectedItemId.control, selectedItem)
            force_focus(selectedItemId)
        }

        g_lists[listIndex].previousSelectedLine = g_lists[listIndex].selectedLine
        g_lists[listIndex].previousSelectedItem = g_lists[listIndex].selectedItem
        g_lists[listIndex].selectedLine = selectedLine
        g_lists[listIndex].selectedItem = selectedItem

        //g_controls[selectedLineId.control].selected = 1
        //g_controls[selectedItemId.control].selected = 1
    }*/

    g_controls[linesIndex].size.x = mat.max(lineWidth, containerWidth)

    {
        control_resize(id.base)
    }


    var focusedLine ControlId = InvalidControl()
    for i = 0; i < lineCount; i = i + 1 {
        var line ControlId = g_controls[linesIndex].children[i]
        var lineIndex i32 = line.control
        if (g_controls[lineIndex].childFocused > 0) {
            focusedLine = line
            i = lineCount
        }
    }


    /*if (IsValidControl(focusedLine)) {
       g_controls[linesIndex].position.x = g_lists[listIndex].offset.x
       g_controls[linesIndex].position.y = g_lists[listIndex].offset.y
    }*/

    //printf("columnCount %d\n", g_controls[headerIndex].childCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_render(id list_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_list(id), "render_list : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// LIFTER
//-----------------------------------------------------------------------------
var LIFT_VERT i32 = 0
var LIFT_HORZ i32 = 1

type lifter_id struct {
    base ControlId
    lifter i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type lifter_s struct {
    id lifter_id
    carret ControlId
    direction i32
    offset f32
    size f32
    dragged bool
    dragBegin mat.v2
    dragEnd mat.v2
    dragDelta mat.v2
    dragOffset f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_id_(base ControlId, lifter i32) (out lifter_id) {
    out.base = base
    out.lifter = lifter
    panicIfNot(is_valid_lifter(out), "lifter_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_lifter(id lifter_id) (out bool) {
    out = id.lifter >= 0 && id.lifter < len(g_lifters) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_lifter() (out lifter_id) {
    out.base = InvalidControl()
    out.lifter = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_size(id lifter_id, value f32) {
    panicIfNot(is_valid_lifter(id), "lifter_set_size : invalid id")
    g_lifters[id.lifter].size = value
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_lifters[] lifter_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_create(name str) (out lifter_id) {
    out.lifter = len(g_lifters)
    out.base = controlCreate(name, GUI_LIFTER, out.lifter)

    var lifter lifter_s


    ControlSetSkin(out.base, g_blackSkin)

    var carret ControlId = ControlCreate("carret")

    lifter.id = out
    lifter.carret = carret

    ControlAddChild(out.base, carret)
    //ControlSetDock(carret, DOCK_TOP)
    //ControlSetSize(carret, mat.v2_(0.03, 0.03 * gfx.gfx_ratio_y))
    ControlSetSkin(carret, g_buttonSkin)
    ControlSetFocusable(carret, 1)

    g_lifters = append(g_lifters, lifter)
    panicIfNot(is_valid_lifter(out), "create_lifter : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_direction(id lifter_id, direction i32) {
    panicIfNot(is_valid_lifter(id), "lifter_set_direction : invalid id")
    panicIfNot(direction == LIFT_VERT || direction == LIFT_HORZ, "lifter_set_direction : unknown direction")
    g_lifters[id.lifter].direction = direction
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_process_event(id lifter_id, event *event_s) (out i32) {
    panicIfNot(is_valid_lifter(id), "lifter_process_event : invalid id")
    out = control_process_event(id.base, event)

    var mouseAction i32 = (*event).mouse.action
    var mouseButton i32 = (*event).mouse.button
    if mouseButton == BUTTON_LEFT {
        if mouseAction == MOUSE_RELEASE {
            var dragged bool = g_lifters[id.lifter].dragged
            if dragged {
                var begin mat.v2 = g_lifters[id.lifter].dragBegin
                var end mat.v2 = g_lifters[id.lifter].dragEnd
                var delta mat.v2 = begin - end
            }
            g_lifters[id.lifter].dragged = false
            g_lifters[id.lifter].dragBegin = mat.v2_(0.0, 0.0)
            g_lifters[id.lifter].dragEnd = mat.v2_(0.0, 0.0)
            g_lifters[id.lifter].dragDelta = mat.v2_(0.0, 0.0)
            g_lifters[id.lifter].dragOffset = lifter_get_offset(id)
            printf("MOUSE_RELEASE %f, %f\n", (*event).mouse.position.x, (*event).mouse.position.y)
        }
    }

    //ControlPrint("LIFTER", id.base, false)
    if (out == EVENT_UNUSED) {
        var focused i32 = g_controls[id.base.control].childFocused
        if (focused > 0) {
            var mods i32 = ((*event).keyboard).mods
            if (mods == MOD_NONE) {
                var action i32 = ((*event).keyboard).action
                if (action == KEY_PRESS) {
                    var key i32 = ((*event).keyboard).key
                    var direction i32 = g_lifters[id.lifter].direction
                    var carret ControlId = g_lifters[id.lifter].carret
                    var offset f32 = lifter_get_offset(id)
                    if (key == KEYCODE_LEFT ||
                        key == KEYCODE_UP) {
                        if (direction == LIFT_HORZ ||
                            direction == LIFT_VERT) {
                            offset = offset - 3.0
                            out = EVENT_CONSUMED
                            force_focus(carret)
                        } else {
                            panicIfNot(false, "lifter_process_event : unknown direction")
                        }
                    } else if (key == KEYCODE_RIGHT ||
                               key == KEYCODE_DOWN) {
                        if (direction == LIFT_HORZ ||
                            direction == LIFT_VERT) {
                            offset = offset + 3.0
                            out = EVENT_CONSUMED
                            force_focus(carret)
                        } else {
                            panicIfNot(false, "lifter_process_event : unknown direction")
                        }
                    }
                    lifter_set_offset(id, offset)
                } else if (mouseAction == MOUSE_PRESS) {
                    g_lifters[id.lifter].dragged = true
                    g_lifters[id.lifter].dragBegin = (*event).mouse.position
                    g_lifters[id.lifter].dragEnd = (*event).mouse.position
                    g_lifters[id.lifter].dragOffset = lifter_get_offset(id)
                    g_lifters[id.lifter].dragDelta = mat.v2_(0.0, 0.0)
                    printf("MOUSE_PRESS %f, %f\n", (*event).mouse.position.x, (*event).mouse.position.y)
                    out = EVENT_CONSUMED
                } else if (mouseAction == MOUSE_MOVE) {
                    var dragged bool = g_lifters[id.lifter].dragged
                    if dragged {
                        g_lifters[id.lifter].dragEnd = (*event).mouse.position
                        var begin mat.v2 = g_lifters[id.lifter].dragBegin
                        var end mat.v2 = g_lifters[id.lifter].dragEnd
                        var dragOffset f32 = g_lifters[id.lifter].dragOffset
                        var delta mat.v2 = mat.v2_sub(begin, end)

                        printf("BEGIN %f, %f, END %f, %f\n", begin.x, begin.y, end.x, end.y)
                        var dragDelta f32 = 0.0
                        if (direction == LIFT_HORZ) {
                            dragDelta = delta.x
                        } else if (direction == LIFT_VERT) {
                            dragDelta = delta.y
                        } else {
                            panic(false, true, "lifter_process_event : invalid direction")
                        }
                        printf("MOUSE_MOVE : %f, %f, %f, %f, %f\n", delta.x, delta.y, dragOffset, dragDelta, dragOffset + dragDelta)
                        lifter_set_offset(id, dragOffset + dragDelta)
                    }
                }
            }
        }
    }
    //printf("list_process_event : OUT %d\n", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_amount(id lifter_id) (out f32) {
    panicIfNot(is_valid_lifter(id), "lifter_get_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    var carret ControlId = g_lifters[id.lifter].carret
    if (direction == LIFT_HORZ) {
        out = g_controls[carret.control].size.x
    } else if (direction == LIFT_VERT) {
        out = g_controls[carret.control].size.y
    } else {
        panicIfNot(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_amount(id lifter_id, value f32) {
    panicIfNot(is_valid_lifter(id), "lifter_set_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    var carret ControlId = g_lifters[id.lifter].carret
    if (direction == LIFT_HORZ) {
        g_controls[carret.control].size.x = value
    } else if (direction == LIFT_VERT) {
        g_controls[carret.control].size.y = value
    } else {
        panicIfNot(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_max_amount(id lifter_id) (out f32) {
    panicIfNot(is_valid_lifter(id), "lifter_get_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    var size mat.v2 = g_controls[id.base.control].size
    if (direction == LIFT_HORZ) {
        out = size.x
    } else if (direction == LIFT_VERT) {
        out = size.y
    } else {
        panicIfNot(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_max_amount(id lifter_id, value f32) {
    panicIfNot(is_valid_lifter(id), "lifter_set_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    if (direction == LIFT_HORZ) {
        g_controls[id.base.control].size.x = value
    } else if (direction == LIFT_VERT) {
        g_controls[id.base.control].size.y = value
    } else {
        panicIfNot(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_offset(id lifter_id) (out f32) {
    panicIfNot(is_valid_lifter(id), "lifter_get_amount : invalid id")
    out = g_lifters[id.lifter].offset
    /*var direction i32 = g_lifters[id.lifter].direction
    var carret ControlId = g_lifters[id.lifter].carret
    if (direction == LIFT_HORZ) {
        out = g_controls[carret.control].position.x
    } else if (direction == LIFT_VERT) {
        out = g_controls[carret.control].position.y
    } else {
        panicIfNot(false, "invalid direction")
    }*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_offset(id lifter_id, value f32) {
    panicIfNot(is_valid_lifter(id), "lifter_set_amount : invalid id")

    var offset f32 = value
    var maxAmount f32 = lifter_get_max_amount(id)
    var amount f32 = lifter_get_amount(id)
    if (offset + amount > maxAmount) {
        offset = maxAmount - amount
    }
    if (offset < 0.0) {
        offset = 0.0
    }

    g_lifters[id.lifter].offset = offset
    /*var direction i32 = g_lifters[id.lifter].direction
    if (direction == LIFT_HORZ) {
        g_controls[carret.control].position.x = value
    } else if (direction == LIFT_VERT) {
        g_controls[carret.control].position.y = value
    } else {
        panicIfNot(false, "invalid direction")
    }*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_max_offset(id lifter_id) (out f32) {
    panicIfNot(is_valid_lifter(id), "lifter_get_max_offset : invalid id")
    var maxAmount f32 = lifter_get_max_amount(id)
    var amount f32 = lifter_get_amount(id)
    out = maxAmount - amount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_resize(id lifter_id) () {
    panicIfNot(is_valid_lifter(id), "resize_lifter : invalid id")

    var lifterIndex i32 = id.lifter
    var direction i32 = g_lifters[lifterIndex].direction

    //var center ControlId = g_lifters[lifterIndex].center
    //var centerIndex i32 = center.control

    var carret ControlId = g_lifters[lifterIndex].carret
    var carretIndex i32 = carret.control

    var lifterSize f32 = g_lifters[id.lifter].size

    {
        control_resize(id.base)
    }

    var offset f32 = lifter_get_offset(id)

    if (direction == LIFT_HORZ) {
        g_controls[carret.control].position.x = offset
        g_controls[carretIndex].size.y = lifterSize * gfx.gfx_ratio_y
    } else if (direction == LIFT_VERT) {
        var centerH f32 = g_controls[id.base.control].size.y
        var carretH f32 = g_controls[carret.control].size.y

        var offsetY f32 = centerH - carretH - offset
        //printf("REOFFSET %f, %f, %f, %f\n", offset, carretH, centerH, offsetY)
        g_controls[carret.control].position.y = offsetY
        g_controls[carretIndex].size.x = lifterSize
    } else {
        panicIfNot(false, "lifter_resize : unknown direction")
    }

    lifter_set_offset(id, offset)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_render(id lifter_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_lifter(id), "render_lifter : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// SCROLLER
//-----------------------------------------------------------------------------
type scroller_id struct {
    base ControlId
    scroller i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type scroller_s struct {
    id scroller_id
    panel ControlId
    container ControlId
    containee ControlId
    vlift lifter_id
    hlift lifter_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_id_(base ControlId, scroller i32) (out scroller_id) {
    out.base = base
    out.scroller = scroller
    panicIfNot(is_valid_scroller(out), "scroller_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_scroller(id scroller_id) (out bool) {
    out = id.scroller >= 0 && id.scroller < len(g_scrollers) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_set_containee(id scroller_id, containee ControlId) {
    panicIfNot(is_valid_scroller(id), "scroller_set_containee : invalid id")
    panicIfNot(IsValidControl(containee), "scroller_set_containee : invalid control")
    var container ControlId = g_scrollers[id.scroller].container
    ControlClearChildren(container)
    ControlAddChild(container, containee)
    g_scrollers[id.scroller].containee = containee
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_scrollers[] scroller_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_create(name str) (out scroller_id) {
    out.scroller = len(g_scrollers)
    out.base = controlCreate(name, GUI_SCROLLER, out.scroller)

    var lifterSize f32 = 8.0

    var scroller scroller_s
    scroller.id = out

    var vlift lifter_id = lifter_create("vlift")
    ControlAddChild(out.base, vlift.base)
    ControlSetSize(vlift.base, mat.v2_(lifterSize, 0.0))
    ControlSetDock(vlift.base, DOCK_RIGHT)
    ControlSetFocusIndex(vlift.base, 1)
    //ControlSetSkin(vlift.base, g_debugBlueSkin)
    lifter_set_direction(vlift, LIFT_VERT)
    lifter_set_size(vlift, lifterSize)
    scroller.vlift = vlift

    var panel ControlId = ControlCreate("panel")
    ControlAddChild(out.base, panel)
    ControlSetDock(panel, DOCK_FILL)
 //   ControlSetAutosize(panel, AUTOSIZE_Y)
    ControlSetFocusIndex(panel, 0)
    scroller.panel = panel

    var hlift lifter_id = lifter_create("hlift")
    ControlAddChild(panel, hlift.base)
    ControlSetSize(hlift.base, mat.v2_(0.0, lifterSize))
    ControlSetDock(hlift.base, DOCK_BOTTOM)
    ControlSetFocusIndex(hlift.base, 1)
    //ControlSetSkin(hlift.base, g_greenSkin)
    lifter_set_direction(hlift, LIFT_HORZ)
    lifter_set_size(hlift, lifterSize)
    scroller.hlift = hlift

    var container ControlId = ControlCreate("container")
    ControlAddChild(panel, container)
    ControlSetDock(container, DOCK_FILL)
    //ControlSetAutosize(container, AUTOSIZE_Y)
    //ControlSetSkin(container, g_blueSkin)
    ControlSetFocusIndex(container, 0)
    scroller.container = container

    g_scrollers = append(g_scrollers, scroller)
    panicIfNot(is_valid_scroller(out), "create_scroller : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_process_event(id scroller_id, event *event_s) (out i32) {
    panicIfNot(is_valid_scroller(id), "scroller_process_event : invalid id")
    //ControlPrint("SCROLLER", id.base, false)
    out = EVENT_UNUSED
    var vlift lifter_id = g_scrollers[id.scroller].vlift
    var vliftFocused i32 = ControlFocused(vlift.base)

    var hlift lifter_id = g_scrollers[id.scroller].hlift
    var hliftFocused i32 = ControlFocused(hlift.base)

    if (vliftFocused > 0 || hliftFocused > 0) {
        var action i32 = ((*event).keyboard).action
        if (action == KEY_PRESS) {
            var key i32 = ((*event).keyboard).key
            var lift lifter_id = invalid_lifter()
            if (/*hliftFocused > 0 &&*/
                (key == KEYCODE_LEFT ||
                 key == KEYCODE_RIGHT)) {
                lift = hlift
                ControlPrint("HLIFT ", hlift.base, false)
            } else if (/*vliftFocused > 0 &&*/
                      (key == KEYCODE_UP ||
                       key == KEYCODE_DOWN)) {
                lift = vlift
                ControlPrint("VLIFT ", vlift.base, false)
            }

            if (is_valid_lifter(lift)) {
                var visible i32 = g_controls[lift.base.control].visible
                if (visible > 0) {
                    var carret ControlId = g_lifters[lift.lifter].carret
                    force_focus(carret)
                }
            }
        }
    }

    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_resize(id scroller_id) () {
    panicIfNot(is_valid_scroller(id), "resize_scroller : invalid id")

    //ControlPrint("scroller_resize : ", id.base, false)
    var container ControlId = g_scrollers[id.scroller].container
    var maxSize mat.v2 = g_controls[container.control].size
    //printf("MAXSIZE %f, %f\n", maxSize.x, maxSize.y)

    var containee ControlId = g_scrollers[id.scroller].containee
    var curSize mat.v2 = g_controls[containee.control].size
    //printf("CURSIZE %f, %f\n", curSize.x, curSize.y)

    var hlift lifter_id = g_scrollers[id.scroller].hlift
    var vlift lifter_id = g_scrollers[id.scroller].vlift

    var percent mat.v2 = mat.v2_zero
    var offset mat.v2 = mat.v2_(lifter_get_offset(hlift), lifter_get_offset(vlift))
    //printf("OFFSET %f, %f\n", offset.x, offset.y)

    var maxOffset mat.v2 = mat.v2_(lifter_get_max_offset(hlift), lifter_get_max_offset(vlift))
    //printf("MAXOFFSET %f, %f\n", maxOffset.x, maxOffset.y)

    if (curSize.y > 0) {
        var vliftIndex i32 = vlift.lifter
        var vliftMax f32 = lifter_get_max_amount(vlift)
        var vamount f32 = maxSize.y * vliftMax / curSize.y
        //printf("VAMOUNT %f\n", vamount)
        lifter_set_amount(vlift, vamount)
        if (curSize.y <= maxSize.y) {
            g_controls[vlift.base.control].visible = 0
        } else {
            g_controls[vlift.base.control].visible = 1
            if (maxOffset.y > 0.0) {
                percent.y = offset.y * 100.0 / maxOffset.y
            } else {
                percent.y = 0.0
            }
        }
    } else {
        g_controls[vlift.base.control].visible = 0
    }

    if (curSize.x > 0) {
        var hliftIndex i32 = hlift.lifter
        var hliftMax f32 = lifter_get_max_amount(hlift)
        var hamount f32 = maxSize.x * hliftMax / curSize.x
        lifter_set_amount(hlift, hamount)
        var maxOffsetX f32 = lifter_get_max_offset(hlift)
        if (curSize.x <= maxSize.x) {
            g_controls[hlift.base.control].visible = 0
        } else {
            g_controls[hlift.base.control].visible = 1
            percent.x = offset.x * 100.0 / maxOffset.x
        }
    } else {
        g_controls[hlift.base.control].visible = 0
    }

    //printf("percent %f, %f\n", percent.x, percent.y)

/*    var hvisible i32 = g_controls[hlift.base.control].visible
    var vvisible i32 = g_controls[vlift.base.control].visible

    if (hvisible > 0 && vvisible > 0) {
    } else if (hvisible > 0) {
    } else if (vvisible > 0) {
    }
*/

    var widthOffset f32 = maxSize.x - curSize.x
    var heightOffset f32 = maxSize.y - curSize.y
    //panicIfNot(mat.is_nan(curSize.y) == false, "scroller_resize curSize.y nan")
    //panicIfNot(mat.is_nan(maxSize.y) == false, "scroller_resize maxSize.y nan")
    //panicIfNot(mat.is_nan(heightOffset) == false, "scroller_resize heightOffset nan")
    //panicIfNot(mat.is_nan(percent.y) == false, "scroller_resize percent.y nan")
    
    /*if (id.base.control == 38) {
    printf("heightOffset %f\n", heightOffset)

    printf("position.x %f, position.y : heightOffset + percent.y * maxSize.y / 100.0 %f\n", 0.0 - percent.x * maxSize.x / 100.0, heightOffset + percent.y * maxSize.y / 100.0)
    }*/
    g_controls[containee.control].position = mat.v2_(0.0 + percent.x * widthOffset / 100.0, heightOffset - percent.y * heightOffset / 100.0)
    var after mat.v2 = g_controls[containee.control].position

    /*if (id.base.control == 38) {
    printf("AFTER %f, %f\n", after.x, after.y)
    }*/
    control_resize(id.base)
    //if (id.base.control == 38) {
    //printf("offset %f, %f\n", offsetX, offsetY)
    //ControlPrint("scroller_resize : after ", containee, false)
    //}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_render(id scroller_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_scroller(id), "render_scroller : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// BINDER
//-----------------------------------------------------------------------------
type binder_id struct {
    base ControlId
    binder i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type binder_s struct {
    id binder_id
    header ControlId
    container ControlId
    selected i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_id_(base ControlId, binder i32) (out binder_id) {
    out.base = base
    out.binder = binder
    panicIfNot(is_valid_binder(out), "binder_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_binder() (out binder_id) {
    out.base = InvalidControl()
    out.binder = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_binder(id binder_id) (out bool) {
    out = id.binder >= 0 && id.binder < len(g_binders) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_binders[] binder_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_create(name str) (out binder_id) {
    out.binder = len(g_binders)
    out.base = controlCreate(name, GUI_BINDER, out.binder)

    var binder binder_s
    binder.id = out

    var header ControlId = ControlCreate("binder.header")
    ControlAddChild(out.base, header)
    ControlSetDock(header, DOCK_TOP)
    //ControlSetSkin(header, g_debugRedSkin)
    //ControlSetSize(header, mat.v2_(0.0, 0.08))
    ControlSetAutosize(header, AUTOSIZE_Y)
    binder.header = header
    binder.selected = -1
    var container ControlId = ControlCreate("binder.container")
    ControlAddChild(out.base, container)
    ControlSetSkin(container, g_blackSkin)
    ControlSetPadding(container, mat.v4_(3.0, 3.0, 3.0, 0.0))
    ControlSetDock(container, DOCK_FILL)
    binder.container = container

    binder.selected = -1

    g_binders = append(g_binders, binder)
    panicIfNot(is_valid_binder(out), "create_binder : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_on_page(page i32, state i32) {
    var id ControlId = NewControlId(page)
    var headerControl ControlId = g_controls[page].parent
    panicIfNot(IsValidControl(headerControl), "internal error")
    panicIfNot(g_controls[headerControl.control].gui_type == GUI_CONTROL, "internal error")

    var binderControl ControlId = g_controls[headerControl.control].parent
    panicIfNot(IsValidControl(binderControl), "internal error")
    panicIfNot(g_controls[binderControl.control].gui_type == GUI_BINDER, "internal error")

    var pageCount i32 = len(g_controls[headerControl.control].children)
    var i i32 = 0
    for i = 0; i < pageCount; i = i + 1 {
        var child ControlId = g_controls[headerControl.control].children[i]
        if (child.control == page) {
            var binderControlIndex i32 = binderControl.control
            var binderIndex i32 = g_controls[binderControlIndex].gui_index
            g_binders[binderIndex].selected = i
            break
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_add_page(id binder_id, name str, color mat.v4, size i32, control ControlId) {
    panicIfNot(is_valid_binder(id), "binder_add_page : invalid id")
    var header ControlId = g_binders[id.binder].header
    var pageCount i32 = len(g_controls[header.control].children)

    var page LabelId = LabelCreate(sprintf("binder.page_%d", pageCount))
    ControlAddChild(header, page.base)
    ControlSetDock(page.base, DOCK_LEFT)
    ControlSetAutosize(page.base, AUTOSIZE)
    ControlSetSkin(page.base, g_binderPageSkin)
    ControlSetPadding(page.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    ControlSetFocusable(page.base, 1)
    LabelSetFont(page, g_boldFont)
    LabelSetText(page, name)
    LabelSetSize(page, size)
    LabelSetColor(page, color)
    LabelSetAlign(page, ALIGN_CENTER)
    LabelSetOnState(page, "gui", "binder_on_page")
    var container ControlId = g_binders[id.binder].container
    ControlAddChild(container, control)
    ControlSetDock(control, DOCK_FILL)
    ControlSetVisible(control, 0)

    g_binders[id.binder].selected = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_process_event(id binder_id, event *event_s) (out i32) {
    panicIfNot(is_valid_binder(id), "binder_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_resize(id binder_id) () {
    panicIfNot(is_valid_binder(id), "resize_binder : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_resize(id.base)

        var selected i32 = g_binders[id.binder].selected
        var header ControlId = g_binders[id.binder].header
        var container ControlId = g_binders[id.binder].container

        var pageCount i32 = len(g_controls[header.control].children)

        var i i32 = 0
        for i = 0; i < pageCount; i = i + 1 {
            var child ControlId = g_controls[header.control].children[i]
            var page ControlId = g_controls[container.control].children[i]
            //var childFocused i32 = ControlFocused(child)
            if (selected == i) {
                ControlSetVisible(page, 1)
                ControlSetSelected(child, 1)
            } else {
                ControlSetVisible(page, 0)
                ControlSetSelected(child, 0)
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_render(id binder_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_binder(id), "render_binder : invalid id")
    //ControlPrint("binder_render : ", id.base, false)
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}


//-----------------------------------------------------------------------------
// VECTOR
//-----------------------------------------------------------------------------
type vector_id struct {
    base ControlId
    vector i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type vector_s struct {
    id vector_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_id_(base ControlId, vector i32) (out vector_id) {
    out.base = base
    out.vector = vector
    panicIfNot(is_valid_vector(out), "vector_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_vector() (out vector_id) {
    out.base = InvalidControl()
    out.vector = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_vector(id vector_id) (out bool) {
    out = id.vector >= 0 && id.vector < len(g_vectors) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_vectors[] vector_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_create(name str) (out vector_id) {
    out.vector = len(g_vectors)
    out.base = controlCreate(name, GUI_VECTOR, out.vector)

    var vector vector_s
    vector.id = out

    g_vectors = append(g_vectors, vector)
    panicIfNot(is_valid_vector(out), "create_vector : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_process_event(id vector_id, event *event_s) (out i32) {
    panicIfNot(is_valid_vector(id), "vector_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_resize(id vector_id) () {
    panicIfNot(is_valid_vector(id), "resize_vector : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_resize(id.base)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_render(id vector_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_vector(id), "render_vector : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}

//-----------------------------------------------------------------------------
// COMBO
//-----------------------------------------------------------------------------
type combo_id struct {
    base ControlId
    combo i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type combo_s struct {
    id combo_id
    splitter splitter_id
    picture LabelId
    label LabelId
    expand LabelId
    screen ScreenId
    window window_id
    list list_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_id_(base ControlId, combo i32) (out combo_id) {
    out.base = base
    out.combo = combo
    panicIfNot(is_valid_combo(out), "combo_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_combo() (out combo_id) {
    out.base = InvalidControl()
    out.combo = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_combo(id combo_id) (out bool) {
    out = id.combo >= 0 && id.combo < len(g_combos) && IsValidControl(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_combos[] combo_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_get_text(id combo_id) (out LabelId) {
    panicIfNot(is_valid_combo(id), "combo_get_text : invalid id")
    out = g_combos[id.combo].label
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_get_pic(id combo_id) (out LabelId) {
    panicIfNot(is_valid_combo(id), "combo_get_pic : invalid id")
    out = g_combos[id.combo].picture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_get_list(id combo_id) (out list_id) {
    panicIfNot(is_valid_combo(id), "combo_get_list : invalid id")
    out = g_combos[id.combo].list
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_create(name str) (out combo_id) {
    out.combo = len(g_combos)
    out.base = controlCreate(name, GUI_COMBO, out.combo)

    ControlSetPadding(out.base, g_padding)

    var combo combo_s
    combo.id = out

    var screen ScreenId = ScreenCreate(sprintf("combo_screen_%s", name))
    combo.screen = screen
    ControlSetSkin(screen.base, g_popupSkin)
    ControlSetBounds(screen.base, gfx.gfx_viewportBounds)
    ScreenSetDuration(screen, -2.0D)
    ScreenSetModal(screen, true)
    ScreenSetFloating(screen, true)

    var window window_id = window_create(sprintf("combo_window_%s", name))
    ControlAddChild(screen.base, window.base)
    ControlSetSkin(window.base, g_windowSkin)
    ControlSetSize(window.base, mat.v2_(100.0, 100.0))
    ControlSetAutosize(window.base, AUTOSIZE_Y)
    //ControlSetAlign(window.base, ALIGN_CENTER)
    var windowHeader ControlId = g_windows[window.window].header
    ControlSetVisible(windowHeader, 0)
    var windowStrip ControlId = g_windows[window.window].strip
    ControlSetVisible(windowStrip, 0)
    //window_set_caption(window, "combo")
   //         gui.window_add_button(window, "no", "No", "main", "on_exit_app_window_no_state")
     //       gui.window_add_button(window, "yes", "Yes", "main", "on_exit_app_window_yes_state")


    combo.window = window

    var list list_id = list_create(sprintf("combo_list_%s", name))
    ControlSetDock(list.base, DOCK_TOP)
    ControlSetAutosize(list.base, AUTOSIZE_Y)
    var listHeader ControlId = g_lists[list.list].header
    g_controls[listHeader.control].visible = 0
    combo.list = list
    window_set_containee(window, list.base)

    var expand LabelId = LabelCreate(sprintf("combo_expand_%s", name))
    combo.expand = expand
    ControlAddChild(out.base, expand.base)
    ControlSetAutosize(expand.base, AUTOSIZE_X)
  //  ControlSetSize(expand.base, mat.v2_(32.0, 32.0))
    ControlSetDock(expand.base, DOCK_RIGHT)
    LabelSetAlign(expand, ALIGN_CENTER)
    LabelSetFont(expand, g_awesomeBoldFont)
    LabelSetColor(expand, g_blue)
    LabelSetRune(expand, 214)
    LabelSetSize(expand, g_fontSizeSmall)

    var picture LabelId = LabelCreate(sprintf("combo_picture_%s", name))
    combo.picture = picture
    ControlSetAutosize(picture.base, AUTOSIZE_X)
//    ControlSetSize(picture.base, mat.v2_(32.0, 32.0))
    ControlSetDock(picture.base, DOCK_LEFT)
    LabelSetAlign(picture, ALIGN_CENTER)
    LabelSetFont(picture, g_awesomeBoldFont)

    var label LabelId = LabelCreate(sprintf("combo_label_%s", name))
    combo.label = label
    ControlSetAutosize(label.base, AUTOSIZE_X)
    ControlSetDock(label.base, DOCK_LEFT)
    LabelSetAlign(label, ALIGN_CENTER)

    var splitter splitter_id = splitter_create(sprintf("combo_splitter_%s", name))
    combo.splitter = splitter
    ControlAddChild(out.base, splitter.base)
    ControlSetDock(splitter.base, DOCK_RIGHT)
    ControlSetAutosize(splitter.base, AUTOSIZE_X)
    ControlSetSpacing(splitter.base, g_spacing_x)
    ControlSetPadding(splitter.base, mat.v4_(5.0, 0.0, 0.0, 0.0))
    splitter_set_direction(splitter, SPLIT_LEFT)
    splitter_set_controls(splitter, picture.base, label.base)

    g_combos = append(g_combos, combo)
    panicIfNot(is_valid_combo(out), "create_combo : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_process_event(id combo_id, event *event_s) (out i32) {
    out = EVENT_UNUSED
    panicIfNot(is_valid_combo(id), "combo_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible

    if (visible > 0) {
        var index i32 = id.base.control
        var focused i32 = g_controls[index].focused
        var mods i32 = ((*event).keyboard).mods

        if (mods == MOD_NONE) { // ##1 refactor with LabelProcessEvent
            var call bool = false
            var button i32 = (*event).mouse.button
            if (button == BUTTON_LEFT) {
                var action i32 = (*event).mouse.action
                if (action == MOUSE_PRESS) {
                    //printf("MOUSE_PRESS\n")
                    var hovered i32 = g_controls[id.base.control].hovered
                    if (hovered > 0) {
                        call = true
                    }
                }
            } else if (focused > 0) {
                var key i32 = (*event).keyboard.key
                if (key == KEYCODE_ENTER || key == KEYCODE_SPACE) {
                    var action i32 = ((*event).keyboard).action
                    if (action == KEY_PRESS) {
                        call = true
                    }
                }
            }

            if (call == true) {
                var screen ScreenId = g_combos[id.combo].screen
                ScreenShow(screen)
                out = EVENT_CONSUMED
            }
        }
    }

    if (out == EVENT_UNUSED) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_resize(id combo_id) () {
    panicIfNot(is_valid_combo(id), "resize_combo : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        var list list_id = g_combos[id.combo].list
        var scroller scroller_id = g_lists[list.list].scroller
        var panel ControlId = g_scrollers[scroller.scroller].panel
        var container ControlId = g_scrollers[scroller.scroller].container

        ControlSetDock(scroller.base, DOCK_TOP)
        ControlSetAutosize(scroller.base, AUTOSIZE_Y)

        ControlSetDock(panel, DOCK_TOP)
        ControlSetAutosize(panel, AUTOSIZE_Y)

        ControlSetDock(container, DOCK_TOP)
        ControlSetAutosize(container, AUTOSIZE_Y)

        control_resize(id.base)

        var screen ScreenId = g_combos[id.combo].screen
        //printf("AAAAAAAA\n")
        if (modal_is_visible(screen) == true) {
        //printf("BBBBBB\n")
            var window window_id = g_combos[id.combo].window
            var comboPosition mat.v2 = g_controls[id.base.control].renderPosition
            var windowSize mat.v2 = g_controls[window.base.control].size
            //printf("###################################################### WINDOW SIZE %f\n", windowSize.y)
            comboPosition.y = comboPosition.y - windowSize.y
            ControlSetPosition(window.base, comboPosition)
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_render(id combo_id, clip mat.v4, stack i32) () {
    panicIfNot(is_valid_combo(id), "render_combo : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update(deltaTime f64)() { // ##1 rewrite
    process_events()
    //printf("UPDATE %d, %d\n", g_currentScreen.screen, g_nextScreen.screen)
    if (IsValidScreen(g_currentScreen)) {
        ScreenUpdate(g_currentScreen, deltaTime)
        if (ScreenStateChanged(g_currentScreen, STATE_OPENED, STATE_CLOSING)) {
            g_nextScreen = g_screens[g_currentScreen.screen].on_next // ##issue_58 issue array index with struct
            printf("NEXT_SCREEN %d\n", g_nextScreen.screen)
            printf("CURRENT %d, NEXT %d\n", g_currentScreen.screen, g_nextScreen.screen)
            g_transitionTime = 0.0D
            g_screens[g_currentScreen.screen].prevState= g_screens[g_currentScreen.screen].state
            printf("screen : %d, STATE_CLOSING\n", g_currentScreen.screen)
        } else if (ScreenStateChanged(g_currentScreen, STATE_CLOSING, STATE_CLOSED)) {
            g_screens[g_currentScreen.screen].time = 0.0D
            g_screens[g_currentScreen.screen].prevState = g_screens[g_currentScreen.screen].state
            g_currentScreen = g_nextScreen
            printf("screen : %d, STATE_CLOSED\n", g_currentScreen.screen)
        }
    }

    if (g_currentScreen.screen != g_nextScreen.screen) {
        if (IsValidScreen(g_nextScreen)) {
            ScreenUpdate(g_nextScreen, deltaTime)
        }

        if (g_transitionTime <= 0) {
            printf("TRANSITION STARTED %f\n", f64.f32(g_transitionTime + deltaTime))
            g_transitionTime = g_transitionTime + deltaTime
        } else if (g_transitionTime <= g_transitionDuration) {
            g_transitionTime = g_transitionTime + deltaTime
        } else {
            printf("TRANSITION ENDED\n")
            if (IsValidScreen(g_currentScreen)) {
                printf("CHANGE CLOSED\n")
                ScreenChangeState(g_currentScreen, STATE_CLOSED)
                printf("prev screen : %d, %d, %s\n", g_currentScreen.screen, g_screens[g_currentScreen.screen].state, "STATE_CLOSED")
            }

            g_currentScreen = g_nextScreen
            printf("CURRENT_SCREEN %d\n", g_nextScreen.screen)
            if (IsValidScreen(g_nextScreen)) {
                var nextScreen ScreenId = g_screens[g_nextScreen.screen].on_next
                printf("CHANGE OPENED\n")
                ScreenChangeState(g_nextScreen, STATE_OPENED)
                printf("next screen : %d, %d, %s\n", g_nextScreen.screen, g_screens[g_nextScreen.screen].state, "STATE_OPENED")
                g_transitionTime = 0.0D
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var BUTTON_LEFT  i32 = 0
var BUTTON_RIGHT i32 = 1

var MOUSE_RELEASE i32 = 0
var MOUSE_PRESS   i32 = 1
var MOUSE_MOVE    i32 = 38

var KEY_RELEASE i32 = 0
var KEY_PRESS   i32 = 1
var KEY_REPEAT  i32 = 2

var KEYCODE_SPACE     i32 =  32
var KEYCODE_ESCAPE    i32 = 256
var KEYCODE_ENTER     i32 = 257
var KEYCODE_TAB       i32 = 258
var KEYCODE_RIGHT     i32 = 262
var KEYCODE_LEFT      i32 = 263
var KEYCODE_DOWN      i32 = 264
var KEYCODE_UP        i32 = 265
var KEYCODE_LEFT_CTRL i32 = 341
var KEYCODE_SHIFT     i32 = 340
var KEYCODE_MENU      i32 = 343

var MOD_NONE  i32 = 0
var MOD_SHIFT i32 = 1
var MOD_CTRL  i32 = 2
var MOD_ALT   i32 = 4
var MOD_MENU  i32 = 8

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func skip_screens()() {
    var next bool = true
    var skipId ScreenId = g_currentScreen
    for (next == true) {
        var nextId ScreenId = g_screens[skipId].on_next
        if (IsValidScreen(nextId)) {
            if (IsValidScreen(g_screens[nextId.screen].on_exit) ||
                IsValidScreen(g_screens[nextId.screen].on_enter) ||
                IsValidScreen(g_screens[nextId.screen].on_menu)) {
                next = false
            }
            skipId = nextId
        } else {
            next = false
        }
    }
    g_nextScreen = skipId
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var EVENT_ERROR    i32 = 0
var EVENT_UNUSED   i32 = 1
var EVENT_CONSUMED i32 = 2

type keyboard_event_s struct {
    key i32
    scancode i32
    action i32
    mods i32
}

type mouse_event_s struct {
    position mat.v2
    button i32
    action i32
    mods i32
}

type event_s struct {
    keyboard keyboard_event_s
    mouse mouse_event_s
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_keyboard_event() (out keyboard_event_s) {
    out.key = -1
    out.scancode = -1
    out.action = 0
    out.mods = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_mouse_event() (out mouse_event_s) {
    out.position = mat.v2_(-1.0, -1.0)
    out.button = -1
    out.action = 0
    out.mods = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_event() (out event_s) {
    out.keyboard = invalid_keyboard_event()
    out.mouse = invalid_mouse_event()
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_process_event(id ControlId, event *event_s) (out i32) {
    panicIfNot(IsValidControl(id), "control_process_event : invalid id")
    out = EVENT_UNUSED

    /*if (id.control == 158) {
        ControlPrint("TOTO :", id, false)
    }*/

    var childHovered i32 = 0
    var parent ControlId = g_controls[id.control].parent
    if (IsValidControl(parent)) {
        var parentHovered i32 = g_controls[parent.control].hovered
        if (parentHovered > 0) {
            childHovered = ControlHovered(id)
        }
    } else {
        childHovered = ControlHovered(id)
    }
    g_controls[id.control].hovered = childHovered
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
        //ControlPrint("control_process_event : ", id, false)

        if childHovered > 0 {
            var focusable i32 = g_controls[id.control].focusable
            if (focusable > 0) {
                var action i32 = (*event).mouse.action
                if (action == MOUSE_PRESS) {
                   force_focus(id)
                }
            }
        }

        var index i32 = id.control
        var count i32 = len(g_controls[index].children)
        for i := 0; i < count; i = i + 1 {
            var child ControlId = g_controls[index].children[i]
            panicIfNot(IsValidControl(child), "control_process_event : invalid child control")
            var childVisible i32 = g_controls[child.control].visible
            if (childVisible > 0) {
                var guiType i32 = g_controls[child.control].gui_type
                var guiIndex i32 = g_controls[child.control].gui_index

                if (guiType == GUI_INVALID) {
                   panicIfNot(false, "invalid gui type (GUI_INVALID)")
                } else if (guiType == GUI_CONTROL) {
                    panicIfNot(guiIndex == child.control, "unexpected error")
                    out = control_process_event(NewControlId(guiIndex), event)
                } else if (guiType == GUI_SCREEN) {
                    out = ScreenProcessEvent(NewScreenId(child, guiIndex), event)
                } else if (guiType == GUI_PICTURE) {
                    out = PictureProcessEvent(NewPictureId(child, guiIndex), event)
                } else if (guiType == GUI_LABEL) {
                    out = LabelProcessEvent(NewLabelId(child, guiIndex), event)
                } else if (guiType == GUI_PARTITION) {
                    out = partition_process_event(partition_id_(child, guiIndex), event)
                } else if (guiType == GUI_KEYBOARD) {
                    out = keyboard_process_event(keyboard_id_(child, guiIndex), event)
                } else if (guiType == GUI_WINDOW) {
                    out = window_process_event(window_id_(child, guiIndex), event)
                } else if (guiType == GUI_GRAPH) {
                    out = graph_process_event(graph_id_(child, guiIndex), event)
                } else if (guiType == GUI_SPLITTER) {
                    out = splitter_process_event(splitter_id_(child, guiIndex), event)
                } else if (guiType == GUI_LIST) {
                    out = list_process_event(list_id_(child, guiIndex), event)
                } else if (guiType == GUI_SCROLLER) {
                    out = scroller_process_event(scroller_id_(child, guiIndex), event)
                } else if (guiType == GUI_LIFTER) {
                    out = lifter_process_event(lifter_id_(child, guiIndex), event)
                } else if (guiType == GUI_BINDER) {
                    out = binder_process_event(binder_id_(child, guiIndex), event)
                } else if (guiType == GUI_VECTOR) {
                    out = vector_process_event(vector_id_(child, guiIndex), event)
                } else if (guiType == GUI_COMBO) {
                    out = combo_process_event(combo_id_(child, guiIndex), event)
                } else {
                    printf("GUI TYPE %d\n", guiType)
                    panicIfNot(false, "control_process_event : unknown gui type")
                }
            }

            if (out == EVENT_CONSUMED) {
                i = count // ##pending issue brue
            } else if (out == EVENT_ERROR) {
                panicIfNot(false, "EVENT_ERROR")
            } else if (out != EVENT_UNUSED) {
                panicIfNot(false, "invalid EVENT code")
            }
        }
        //ControlPrint("control_process_event : ", id, false)
        //printf("control_process_event : OUT %d\n", out)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func hide_modal(id ScreenId) {
    panicIfNot(IsValidScreen(id), "hide_modal : invalid screen")
    var modalCount i32 = len(g_modals)
    panicIfNot(modalCount > 0, "hide_modal : invalid count")
    if (modalCount > 0) {
        var modalIndex i32 = modalCount - 1
        printf("MODAL_INDEX %d, COUNT %d\n", modalIndex, modalCount)
        var modalScreen ScreenId = g_modals[modalIndex]
        panicIfNot(modalScreen.screen == id.screen, "hide_modal : invalid screen")
        if (modalScreen.screen == id.screen) {
            printf("ScreenHide\n")
            ScreenHide(modalScreen)
            g_modals = resize(g_modals, modalIndex)
            g_hotScreen = InvalidScreen()
        }
    }
    printf("AFTER HIDE_MODEL\n")
}

var g_hotScreen ScreenId

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_events []event_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_cursor(window str, x f64, y f64) {
    var xx f32 = f64.f32(x)
    var yy f32 = gfx.gfx_height - f64.f32(y)

    //printf("cursor : %f, %f\n", xx, yy)
    g_cursorPos.x = xx
    g_cursorPos.y = yy

    var event event_s = invalid_event()
    event.mouse.position = g_cursorPos
    event.mouse.action = MOUSE_MOVE

    g_events = append(g_events, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_button(window str, key i32, action i32, mods i32) {
    printf("button : %d, %d, %d\n", key, action, mods)

    var event event_s = invalid_event()
    event.mouse.button = key
    event.mouse.action = action
    event.mouse.mods = mods
    event.mouse.position = g_cursorPos

    g_events = append(g_events, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_keyboard(window str, key i32, scancode i32, action i32, mods i32) () {
    printf("key pressed : %d, scancode %d, action %d, mods %d\n", key, scancode, action, mods)

    var event event_s = invalid_event()
    event.keyboard.key = key
    event.keyboard.scancode = scancode
    event.keyboard.action = action
    event.keyboard.mods = mods

    g_events = append(g_events, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_events() () {
    var i i32 = 0
    var eventCount i32 = len(g_events)
    for i = 0; i < eventCount; i = i + 1 {
        var event event_s = g_events[i]
        process_event(&event)
    }
    g_events = resize(g_events, 0)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_event(event *event_s) () {
    var action i32 = (*event).keyboard.action
    var key i32 = (*event).keyboard.key
    var mods i32 = (*event).keyboard.mods

    var button i32 = (*event).mouse.button
    var buttonAction i32 = (*event).mouse.action

    var currentScreen ScreenId = InvalidScreen()
    var modalCount i32 = len(g_modals)
    if (modalCount > 0) {
        var modalIndex i32 = modalCount - 1
        var modalScreen ScreenId = g_modals[modalIndex]
        g_hotScreen = modalScreen
        currentScreen = modalScreen
        var floating bool = g_screens[modalScreen.screen].floating
        if (control_process_event(modalScreen.base, event) == EVENT_UNUSED) {
            if ((key == KEYCODE_ESCAPE && action == KEY_PRESS) ||
                (button == BUTTON_LEFT && buttonAction == MOUSE_PRESS && floating == true)) {
                hide_modal(modalScreen)
                g_hotScreen = g_currentScreen
            } else {
                currentScreen = modalScreen
                g_hotScreen = modalScreen
            }
        }
    } else if (IsValidScreen(g_currentScreen)) {
        g_hotScreen = g_currentScreen
        //printf("NO MODAL\n")
        if (control_process_event(g_currentScreen.base, event) == EVENT_UNUSED) {
        //printf("process_keyboard : EVENT_UNUSED 0\n")
            var screen i32 = g_currentScreen.screen
            var state i32 = g_screens[screen].state
            //if (g_screens[g_currentScreen.screen].state == STATE_OPENED) { // ##pending
            //} else if (g_screens[g_currentScreen.screen].state == STATE_SHOWING) { // ##pending
            if (state == STATE_OPENED || state == STATE_SHOWING) {
                if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onExit ScreenId = g_screens[screen].on_exit
                    if (IsValidScreen(onExit) == true) {
                        ScreenShow(onExit)
                    } else {
                        printf("INVALID ON EXIT SCREEN %d, %d\n", onExit.screen, onExit.base)
                    }
                } else if (key == KEYCODE_ENTER && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onEnter ScreenId = g_screens[screen].on_enter
                    if (IsValidScreen(onEnter) == true) {
                        ScreenShow(onEnter)
                    }
                } else if (key == KEYCODE_MENU && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onMenu ScreenId = g_screens[screen].on_menu
                    if (IsValidScreen(onMenu) == true) {
                        ScreenShow(onMenu)
                    }
                } else {
    //printf("process_keyboard : EVENT_UNUSED 1\n")
                    currentScreen = g_currentScreen
                    g_hotScreen = g_currentScreen
                }
            }
        }
    } else {
        g_hotScreen = InvalidScreen()
        //printf("----------------------------------------------->\n")
    }

    if (IsValidScreen(currentScreen)) {
    //printf("process_keyboard : EVENT_UNUSED 2\n")
        if (action == KEY_PRESS) {
            if (mods == MOD_NONE || mods == MOD_CTRL) {
                if (key == KEYCODE_LEFT ||
                    key == KEYCODE_UP) {
                    set_previous_focus(g_hotScreen)
                } else if (key == KEYCODE_RIGHT ||
                           key == KEYCODE_DOWN ||
                           key == KEYCODE_TAB) {
                    set_next_focus(g_hotScreen)
                }
            } else if (mods == MOD_SHIFT) {
                if (key == KEYCODE_TAB) {
                    set_previous_focus(g_hotScreen)
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func modal_is_visible(id ScreenId) (out bool) {
    out = false
    panicIfNot(IsValidScreen(id), "modal_is_visible : invalid id")
    var modal bool = g_screens[id.screen].modal
    if (modal == true) {
        var modalCount i32 = len(g_modals)
        if (modalCount > 0) {
            var lastIndex i32 = modalCount - 1
            var left i32 = g_modals[lastIndex].screen
            var right i32 = id.screen
            //printf("left %d, right %d\n", left, right)
            if (left == right) {
                out = true
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func ScreenHide(id ScreenId) () {
    panicIfNot(IsValidScreen(id), "ScreenHide : invalid screen")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func ScreenShow(id ScreenId) () {
    panicIfNot(IsValidScreen(id), "ScreenShow : invalid id")
    g_hotScreen = id
    ControlPrint("ScreenShow : ", id.base, false)
    rebuild_focus(id)

    var modal bool = g_screens[id.screen].modal
    if (modal == true) {
        var modalCount i32 = len(g_modals)
        g_modals = append(g_modals, id)
    } else {
        g_nextScreen = id
        g_transitionTime = 0.0D
    }

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize() () {
    clear_batches()
    if (IsValidScreen(g_currentScreen)) {
        reset_scope()
        //printf("-------------------------------------------------------------------------------->\n")
        ScreenResize(g_currentScreen)
        control_redock(g_currentScreen.base, mat.v4_zero)
        //ScreenResize(g_currentScreen)
        //control_redock(g_currentScreen.base, mat.v4_zero)
    }
    if (IsValidScreen(g_nextScreen) && g_currentScreen.screen != g_nextScreen.screen) {
        reset_scope()
        ScreenResize(g_nextScreen)
        control_redock(g_nextScreen.base, mat.v4_zero)
        //ScreenResize(g_nextScreen)
        //control_redock(g_nextScreen.base, mat.v4_zero)
    }

    var i i32 = 0
    var modalCount i32 = len(g_modals)
    for i = 0; i < modalCount; i = i + 1 {
        //ControlPrint("before resize : ", g_modals[i].base, false)
        //printf("_-------------------------------------------------------------------------------->>>>\n")
        reset_scope()
        ScreenResize(g_modals[i])
        control_redock(g_modals[i].base, mat.v4_zero)
        //ScreenResize(g_modals[i])
        //control_redock(g_modals[i].base, mat.v4_zero)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_profileRenderCurrentScreen fps.ProfileId
var g_profileRenderNextScreen fps.ProfileId
var g_profileRenderScreenEffect fps.ProfileId
var g_profileRenderModals fps.ProfileId
var g_profileRenderDefaultFramebuffer fps.ProfileId
var g_profileRenderScreenControl fps.ProfileId
var g_profileRenderOpaqueVertexColoredTriangles fps.ProfileId
var g_profileRenderOpaqueTexturedTriangles fps.ProfileId
var g_profileRenderOpaqueVertexColoredLines fps.ProfileId
var g_profileRenderAlphaVertexColoredTriangles fps.ProfileId
var g_profileRenderAlphaTexturedTriangles fps.ProfileId
var g_profileControlRender fps.ProfileId
var g_profileControlRenderChild fps.ProfileId
var g_profileRenderControlFull fps.ProfileId

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render() () {

    var clip mat.v4 = gfx.gfx_viewportBounds
    var depthTest bool = true
    var depthFunc i32 = gl.GEQUAL
    var depthClear f64 = -1.0D
    var depthWrite bool = true
    var stencilClear i32 = 256

    var clearColor mat.v4 = mat.v4_(0.0, 0.0, 0.0, 0.0)

    fps.Start(g_profileRenderCurrentScreen)
    var target_0 gfx.Target = gfx.InvalidTarget()
    if (IsValidScreen(g_currentScreen)) {
        target_0 = gfx.lock_target(g_width, g_height)
        gfx.bind_framebuffer(target_0.framebuffer)
        gfx.bind_depthbuffer(g_depthStencilBuffer)
        //gfx.bind_stencilbuffer(g_depthStencilBuffer)
        gfx.depth_state(depthTest, depthFunc, depthWrite)
        gfx.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT/* | gl.STENCIL_BUFFER_BIT*/, gfx.gfx_black, depthClear, stencilClear)
        gfx.color_write(true, true, true, true)
        ScreenRender(g_currentScreen, clip, 0)
        gfx.bind_depthbuffer(0)
        gfx.bind_stencilbuffer(0)
    }
    fps.Stop(g_profileRenderCurrentScreen)

    var target_1 gfx.Target = gfx.InvalidTarget()
    fps.Start(g_profileRenderNextScreen)
    if (IsValidScreen(g_nextScreen) && g_nextScreen.screen != g_currentScreen.screen) {
        target_1 = gfx.lock_target(g_width, g_height)
        gfx.bind_framebuffer(target_1.framebuffer)
        gfx.bind_depthbuffer(g_depthStencilBuffer)
        //gfx.bind_stencilbuffer(g_depthStencilBuffer)
        gfx.depth_state(depthTest, depthFunc, depthWrite)
        gfx.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gfx.gfx_black, depthClear, stencilClear)
        gfx.color_write(true, true, true, true)
        ScreenRender(g_nextScreen, clip, 0)
        gfx.bind_depthbuffer(0)
        gfx.bind_stencilbuffer(0)
    }
    fps.Stop(g_profileRenderNextScreen)

    fps.Start(g_profileRenderScreenEffect)
    var target_2 gfx.Target = gfx.InvalidTarget()
    //if (gfx.IsValidTarget(target_0) && gfx.IsValidTarget(target_1)) {
        target_2 = gfx.lock_target(g_width, g_height)
        gfx.bind_framebuffer(target_2.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, gfx.gfx_zero, 0.0D, 0)
        gfx.color_write(true, true, true, true)
        gfx.disable_depth()
        gfx.disable_stencil()
        gfx.disable_blending()
        gfx.EffectUse(gfx.g_fxTrans_0)
        gfx.EffectAssignTexture(gfx.g_fxTrans_0, 0, target_0.texture.name)
        gfx.EffectAssignTexture(gfx.g_fxTrans_0, 1, target_1.texture.name)
        gfx.EffectAssignFloat(gfx.g_fxTrans_0, 0, f64.f32(g_transitionTime / g_transitionDuration))
        gfx.MeshRender(g_fullscreenQuad)
        if (gfx.IsValidTarget(target_0)) {
            gfx.unlock_target(target_0)
        }
        if (gfx.IsValidTarget(target_1)) {
            gfx.unlock_target(target_1)
        }
    /*} else if (gfx.IsValidTarget(target_0)) {
        target_2 = target_0
    } else if (gfx.IsValidTarget(target_1)) {
        target_2 = target_1
    } else {
        panicIfNot(false, "render : invalid target")
    }*/

    fps.Stop(g_profileRenderScreenEffect)

    fps.Start(g_profileRenderModals)
    var i i32 = 0
    var modalCount i32 = len(g_modals)
    for i = 0; i < modalCount; i = i + 1 {
        var target Target = gfx.lock_target(g_width, g_height)
        gfx.bind_framebuffer(target.framebuffer)
        gfx.bind_depthbuffer(g_depthStencilBuffer)
        //gfx.bind_stencilbuffer(g_depthStencilBuffer)
        gfx.depth_state(depthTest, depthFunc, depthWrite)
        //gfx.stencil_state(true, gl.EQUAL, 0, 256, gl.KEEP, gl.KEEP, gl.KEEP, 0)
        gfx.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gfx.gfx_zero, depthClear, stencilClear)
        gfx.color_write(true, true, true, true)
        ScreenRender(g_modals[i], clip, 0)
        gfx.bind_depthbuffer(0)
        gfx.bind_stencilbuffer(0)

        var target_3 Target = gfx.lock_target(g_width, g_height)
        gfx.bind_framebuffer(target_3.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, gfx.gfx_zero, 0.0D, 0)
        gfx.color_write(true, true, true, true)
        gfx.disable_depth()
        gfx.disable_stencil()
        gfx.disable_blending()
        gfx.EffectUse(gfx.g_fxTrans_1)
        gfx.EffectAssignTexture(gfx.g_fxTrans_1, 0, target_2.texture.name)
        gfx.EffectAssignTexture(gfx.g_fxTrans_1, 1, target.texture.name)
        gfx.EffectAssignFloat(gfx.g_fxTrans_1, 0, 1.0)
        gfx.MeshRender(g_fullscreenQuad)
        gfx.unlock_target(target)
        gfx.unlock_target(target_2)
        target_2 = target_3
    }
    fps.Stop(g_profileRenderModals)

    fps.Start(g_profileRenderDefaultFramebuffer)
    // ##todo fast path if no modals => render in default framebuffer 0
    gfx.bind_framebuffer(0)
    gfx.clear(gl.COLOR_BUFFER_BIT, gfx.gfx_zero, 0.0D, 0)
    gfx.color_write(true, true, true, true)
    gfx.disable_depth()
    gfx.disable_stencil()
    gfx.disable_blending()
    gfx.EffectUse(gfx.g_fxTexture)
    gfx.EffectAssignTexture(gfx.g_fxTexture, 0, target_2.texture.name)
    gfx.MeshRender(g_fullscreenQuad)
    gfx.unlock_target(target_2)
    fps.Stop(g_profileRenderDefaultFramebuffer)

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

