package gfx

//-----------------------------------------------------------------------------
// Globals ...
//-----------------------------------------------------------------------------
var g_vaos []i32
var g_vbos []i32
var g_meshes []Mesh
var g_freeMeshes []MeshId
//var g_debugMesh MeshId

//-----------------------------------------------------------------------------
// MeshId ...
//-----------------------------------------------------------------------------
type MeshId struct {
	mesh i32
}

//-----------------------------------------------------------------------------
// Mesh ...
//-----------------------------------------------------------------------------
type Mesh struct {
	id MeshId
	vertices []f32
	attributes []i32
	primitive i32
	vao i32
	vbo i32
	stride i32
	floatCount i32
	vertexCount i32
	dataSize i32
	bufferSize i32
	index i32
}

//-----------------------------------------------------------------------------
// InvalidMesh ...
//-----------------------------------------------------------------------------
func InvalidMesh() (out MeshId) {
	out.mesh = -1
}

//-----------------------------------------------------------------------------
// IsValidMesh ...
//-----------------------------------------------------------------------------
func IsValidMesh(id MeshId) (out bool) {
	out = id.mesh >= 0 && id.mesh < len(g_meshes)
}

//-----------------------------------------------------------------------------
// MeshPrint ...
//-----------------------------------------------------------------------------
func MeshPrint(message str, id MeshId) {
	panicIfNot(IsValidMesh(id), "invalid id")
	var index i32 = id.mesh
	printf("id %d, vertices %d, attributes %d, primitive %d, vao %d, vbo %d, stride %d, floatCount %d, vertexCount %d, dataSize %d, bufferSize %d, index %d\n",
		index,
		len(g_meshes[index].vertices),
		len(g_meshes[index].attributes),
		g_meshes[index].primitive,
		g_meshes[index].vao,
		g_meshes[index].vbo,
		g_meshes[index].stride,
		g_meshes[index].floatCount,
		g_meshes[index].vertexCount,
		g_meshes[index].dataSize,
		g_meshes[index].bufferSize,
		len(g_meshes[index].vertices))
}

//-----------------------------------------------------------------------------
// MeshIsEmpty ...
//-----------------------------------------------------------------------------
func MeshIsEmpty(id MeshId) (out bool) {
	panicIfNot(IsValidMesh(id), "invalid id")
	var mesh i32 = id.mesh
	var index i32 = len(g_meshes[mesh].vertices)
	out = index <= 0
}

//-----------------------------------------------------------------------------
// MeshLock ...
//-----------------------------------------------------------------------------
func MeshLock(primitive i32, attributes []i32, vertexCount i32) (out MeshId) {
	var freeMeshCount i32 = len(g_freeMeshes)
	if (freeMeshCount > 0) {
		var newFreeMeshCount i32 = freeMeshCount - 1
		out.mesh = g_freeMeshes[newFreeMeshCount].mesh
		g_freeMeshes = resize(g_freeMeshes, newFreeMeshCount)
	} else {
		out = MeshCreate(primitive, attributes, vertexCount)
	}
	panicIfNot(IsValidMesh(out), "invalid id")
}

//-----------------------------------------------------------------------------
// MeshUnlock ...
//-----------------------------------------------------------------------------
func MeshUnlock(id MeshId) {
	panicIfNot(IsValidMesh(id), "invalid id")
	g_freeMeshes = append(g_freeMeshes, id)
}

//-----------------------------------------------------------------------------
// MeshCreate ...
//-----------------------------------------------------------------------------
func MeshCreate(primitive i32, Xattributes []i32, vertexCount i32) (out MeshId) {
	out.mesh = len(g_meshes)

	//printf("MeshCreate %d, primitive %d, vertexCount %d\n", out.mesh, primitive, vertexCount)
	panicIfNot((primitive == gl.TRIANGLES || primitive == gl.LINES), "(primitive == gl.TRIANGLES || primitive == gl.LINES)")
	panicIfNot(vertexCount > 0, "vertexCount > 0")

	if primitive == gl.TRIANGLES {
		panicIfNot((vertexCount % 3) == 0, "(vertexCount % 3) == 0")
	} else if primitive == gl.LINES {
		panicIfNot((vertexCount % 2) == 0, "(vertexCount % 2) == 0")
	}

	var mesh Mesh
	mesh.attributes = Xattributes
	mesh.primitive = primitive
	mesh.vao = 0
	mesh.vbo = 0
	mesh.stride = 0
	mesh.floatCount = 0
	mesh.vertexCount = 0
	mesh.dataSize = 0
	mesh.bufferSize = 0

	// stride
	var i i32 = 0
	var attributeCount i32 = len(Xattributes)
	var stride i32 = 0
	//printf("attributeCount %d\n", attributeCount)
	for i = 0; i < attributeCount; i = i + 1 {
		var size i32 = Xattributes[i]
		stride = stride + size
		//printf("mesh.stride %d, stride %d, attributes[i] %d\n", mesh.stride, stride, attributes[i])
	}
	mesh.stride = stride
	panicIfNot(stride > 0, "mesh.stride > 0")

	var floatCount i32 = stride * vertexCount
	panicIfNot(floatCount > 0, "floatCount > 0")

	var bufferSize i32 = floatCount * g_sizeofFloat
	panicIfNot(bufferSize > 0, "bufferSize > 0")

	panicIfNot((floatCount  % stride) == 0, "(floatCount % (*mesh).stride) == 0")
	mesh.bufferSize = bufferSize

	// vbo
	mesh.vbo = gl.GenBuffers(1, mesh.vbo)
	panicIf(GlError(), "gl.GenBuffers")
	g_vbos = append(g_vbos, mesh.vbo)

	gl.BindBuffer(gl.ARRAY_BUFFER, mesh.vbo)
	panicIf(GlError(), "gl.BindBuffer")

	// vao
	mesh.vao = gl.GenVertexArrays(1, mesh.vao)
	panicIf(GlError(), "gl.GenVertexArrays")
	g_vaos = append(g_vaos, mesh.vao)

	gl.BindVertexArray(mesh.vao)
	panicIf(GlError(), "gl.BindVertexArray")

	gl.BindBuffer(gl.ARRAY_BUFFER, mesh.vbo)
	panicIf(GlError(), "gl.BindBuffer")

	//printf("bufferSize %d\n", bufferSize)
	var null []f32
	gl.BufferData(gl.ARRAY_BUFFER, bufferSize, null, gl.DYNAMIC_DRAW)
	panicIf(GlError(), "gl.BufferData")

	var offset i32 = 0
	for i = 0; i < attributeCount; i = i + 1 {
		var floatStride i32 = stride * g_sizeofFloat
		//printf("VertexAttribPointerI32 %d, %d, %d, %d\n", i, Xattributes[i], floatStride, offset)

		gl.EnableVertexAttribArray(i)
		panicIf(GlError(), "gl.EnableVertexAttribArray")

		gl.VertexAttribPointerI32(i, Xattributes[i], gl.FLOAT, false, floatStride, offset)
		panicIf(GlError(), "gl.VertexAttribPointerI32")

		offset = offset + g_sizeofFloat * Xattributes[i]
	}

	g_meshes = append(g_meshes, mesh) // ISSUE : can't use global slice if declared in another file
	panicIfNot(IsValidMesh(out), "invalid id")
}

//-----------------------------------------------------------------------------
// MeshBegin ...
//-----------------------------------------------------------------------------
func MeshBegin(id MeshId) () {
	panicIfNot(IsValidMesh(id), "invalid id")
	var mesh i32 = id.mesh
	g_meshes[mesh].vertices = resize(g_meshes[mesh].vertices, 0)
}

//-----------------------------------------------------------------------------
// MeshEnd ...
//-----------------------------------------------------------------------------
func MeshEnd(id MeshId) () {
	panicIfNot(IsValidMesh(id), "invalid id")

	//MeshPrint("MeshEnd : ", id)

	var mesh i32 = id.mesh
	var floatCount i32 = len(g_meshes[mesh].vertices)
	if floatCount > 0 {
		g_meshes[mesh].floatCount = floatCount //len(g_vertices)
		//printf("floatCount %d\n", g_meshes[mesh].floatCount)

		g_meshes[mesh].dataSize = floatCount * g_sizeofFloat
		//printf("dataSize %d\n", g_meshes[mesh].dataSize)

		//printf("stride %d\n", (*mesh).stride)
		var stride i32 = g_meshes[mesh].stride
		panicIfNot(stride > 0, "invalid stride")
		panicIfNot((floatCount % stride) == 0, "((*mesh).floatCount % (*mesh).stride)) == 0")

		g_meshes[mesh].vertexCount = floatCount / stride
		//printf("vertexCount %d\n", g_meshes[mesh].vertexCount)

		//printf("(*mesh).vbo %d\n", g_meshes[mesh].vbo)
		gl.BindBuffer(gl.ARRAY_BUFFER, g_meshes[mesh].vbo)
		panicIf(GlError(), "gl.BindBuffer")

		gl.BufferSubData(gl.ARRAY_BUFFER, 0, g_meshes[mesh].dataSize, g_meshes[mesh].vertices)
		panicIf(GlError(), "gl.BufferSubData")
	}
}

//-----------------------------------------------------------------------------
// MeshRender ...
//-----------------------------------------------------------------------------
func MeshRender(id MeshId) {
	panicIfNot(IsValidMesh(id), "invalid id")
	var mesh i32 = id.mesh
	gl.BindVertexArray(g_meshes[mesh].vao)
	panicIf(GlError(), "gl.BindVertexArray")

	//printf("MESH %d, VERTEX COUNT %d\n", mesh, g_meshes[mesh].vertexCount)
	gl.DrawArrays(g_meshes[mesh].primitive, 0, g_meshes[mesh].vertexCount)
	panicIf(GlError(), "gl.DrawArrays")
}

//-----------------------------------------------------------------------------
// MeshAppendLine ...
// TODO : pixel coordinates and clipping shouldn't be done in this function
//-----------------------------------------------------------------------------
func MeshAppendLine(id MeshId, line mat.v4, color mat.v4, clip mat.v4, depth f32) () {
	if (clip.z > 0.0 && clip.w > 0.0) {
		panicIfNot(IsValidMesh(id), "invalid id")
		var mesh i32 = id.mesh

		var clipLeft f32 = clip.x
		var clipRight f32 = clip.x + clip.z
		var clipBottom f32 = clip.y
		var clipTop f32 = clip.y + clip.w

		var index i32 = len(g_meshes[mesh].vertices)

		var x0 f32 = line.x
		var y0 f32 = line.y
		var x1 f32 = line.z
		var y1 f32 = line.w

		var cRight bool = x0 > clipRight && x1 > clipRight // ##0 AABB clipping...
		var cLeft bool = x0 < clipLeft && x1 < clipLeft
		var cBottom bool = y0  < clipBottom && y1 < clipBottom
		var cTop bool = y0 > clipTop && y1 > clipTop
		if (cLeft == false && cBottom == false && //cRight == false &&
		cTop == false) {

			var r f32 = color.x
			var g f32 = color.y
			var b f32 = color.z
			var a f32 = color.w

			if (x0 < clipLeft) {
				x0 = clipLeft
			} else if (x0 > clipRight) {
				x0 = clipRight
			}

			if (x1 < clipLeft) {
				x1 = clipLeft
			} else if (x1 > clipRight) {
				x1 = clipRight
			}

			if (y0 < clipBottom) {
				y0 = clipBottom
			} else if (y0 > clipTop) {
				y0 = clipTop
			}

			if (y1 < clipBottom) {
				y1 = clipBottom
			} else if (y1 > clipTop) {
				y1 = clipTop
			}

			x0 = 2.0 * x0 / gfx_width - 1.0
			y0 = 2.0 * y0 / gfx_height - 1.0
			x1 = 2.0 * x1 / gfx_width - 1.0
			y1 = 2.0 * y1 / gfx_height - 1.0

			var vertices []f32 = g_meshes[mesh].vertices

			vertices = append(vertices, x0)
			vertices = append(vertices, y0)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, 0.0)
			vertices = append(vertices, 0.0)

			vertices = append(vertices, x1)
			vertices = append(vertices, y1)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, 0.0)
			vertices = append(vertices, 0.0)

			g_meshes[mesh].vertices = vertices
		}
	}
}

//-----------------------------------------------------------------------------
// MeshAppendRect ...
//-----------------------------------------------------------------------------
func MeshAppendRect(id MeshId, rect mat.v4, left mat.v4, right mat.v4, bottom mat.v4, top mat.v4, clip mat.v4, depth f32) () {
	panicIfNot(IsValidMesh(id), "invalid id")
	var x0 f32 = rect.x
	var y0 f32 = rect.y
	var x1 f32 = x0 + rect.z
	var y1 f32 = y0 + rect.w

	MeshAppendLine(id, mat.v4_(x0, y0, x0, y1), left, clip, depth)
	MeshAppendLine(id, mat.v4_(x1, y0, x1, y1), right, clip, depth)
	MeshAppendLine(id, mat.v4_(x0, y0, x1, y0), bottom, clip, depth)
	MeshAppendLine(id, mat.v4_(x0, y1, x1, y1), top, clip, depth)
}

//-----------------------------------------------------------------------------
// MeshAppendQuad ...
// TODO : pixel coordinate and clipping shouldn't be done in this function
//-----------------------------------------------------------------------------
func MeshAppendQuad(id MeshId, rect mat.v4, uv mat.v4, color mat.v4, clip mat.v4, depth f32) {
	if (clip.z > 0.0 && clip.w > 0.0) {
		panicIfNot(IsValidMesh(id), "invalid id")

		var clipLeft f32 = clip.x
		var clipRight f32 = clip.x + clip.z
		var clipBottom f32 = clip.y
		var clipTop f32 = clip.y + clip.w

		var mesh i32 = id.mesh
		var index i32 = len(g_meshes[mesh].vertices)

		var primitive i32 = g_meshes[mesh].primitive
		panicIfNot(primitive == gl.TRIANGLES, "(*mesh).primitive == gl.TRIANGLES")

		var x f32 = rect.x
		var y f32 = rect.y
		var w f32 = rect.z
		var h f32 = rect.w

		var x1 f32 = x + w
		var y1 f32 = y + h

		var cLeft bool = x < clipLeft && x1 < clipLeft
		var cBottom bool = y  < clipBottom && y1 < clipBottom
		var cRight bool = x > clipRight && x1 > clipRight // ##0 AABB clipping...
		var cTop bool = y > clipTop && y1 > clipTop

		if (cLeft == false && cBottom == false && cRight == false && cTop == false) {
			var r f32 = color.x
			var g f32 = color.y
			var b f32 = color.z
			var a f32 = color.w

			var u0 f32 = uv.x
			var v0 f32 = uv.y
			var u1 f32 = uv.z
			var v1 f32 = uv.w

			var deltaLeft f32 = mat.max(0.0, clipLeft - x)
			var deltaRight f32 = mat.min(0.0, clipRight - x1)

			var deltaBottom f32 = mat.max(0.0, clipBottom - y)
			var deltaTop f32 = mat.min(0.0, clipTop - y1)

			x = mat.max(x, clipLeft)
			y = mat.max(y, clipBottom)

			x1 = mat.min(x1, clipRight)
			y1 = mat.min(y1, clipTop)

			var nw f32 = x1 - x
			var nh f32 = y1 - y

			var du f32 = u1 - u0
			var dv f32 = v0 - v1

			u0 = u0 + du * deltaLeft / w
			u1 = u1 + du * deltaRight / w
			v1 = v1 + dv * deltaBottom / h
			v0 = v0 + dv * deltaTop /h

			x = 2.0 * i32.f32(f32.i32(x)) / gfx_width - 1.0
			y = 2.0 * i32.f32(f32.i32(y)) / gfx_height - 1.0
			x1 = 2.0 * i32.f32(f32.i32(x1)) / gfx_width - 1.0
			y1 = 2.0 * i32.f32(f32.i32(y1)) / gfx_height - 1.0

			var vertices []f32 = g_meshes[mesh].vertices

			vertices = append(vertices, x)
			vertices = append(vertices, y)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, u0)
			vertices = append(vertices, v1)

			vertices = append(vertices, x1)
			vertices = append(vertices, y)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, u1)
			vertices = append(vertices, v1)

			vertices = append(vertices, x)
			vertices = append(vertices, y1)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, u0)
			vertices = append(vertices, v0)

			vertices = append(vertices, x)
			vertices = append(vertices, y1)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, u0)
			vertices = append(vertices, v0)

			vertices = append(vertices, x1)
			vertices = append(vertices, y)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, u1)
			vertices = append(vertices, v1)

			vertices = append(vertices, x1)
			vertices = append(vertices, y1)
			vertices = append(vertices, depth)
			vertices = append(vertices, r)
			vertices = append(vertices, g)
			vertices = append(vertices, b)
			vertices = append(vertices, a)
			vertices = append(vertices, u1)
			vertices = append(vertices, v0)

			g_meshes[mesh].vertices = vertices
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func appendV9(vertices []f32, x f32, y f32, z f32, r f32, g f32, b f32, a f32, u f32, v f32) (out []f32) {
	out = vertices
	out = append(out, x)
	out = append(out, y)
	out = append(out, z)
	out = append(out, r)
	out = append(out, g)
	out = append(out, b)
	out = append(out, a)
	out = append(out, u)
	out = append(out, v)
}

//-----------------------------------------------------------------------------
// MeshAppendCube ...
// TODO : DrawElements
//-----------------------------------------------------------------------------
func MeshAppendCube(id MeshId, position mat.v3, size mat.v3, color mat.v4) {
	panicIfNot(IsValidMesh(id), "invalid id")

	var mesh i32 = id.mesh

	var primitive i32 = g_meshes[mesh].primitive
	panicIfNot(primitive == gl.TRIANGLES, "(*mesh).primitive == gl.TRIANGLES")

	var x f32 = position.x
	var y f32 = position.y
	var z f32 = position.z

	var w f32 = size.x
	var h f32 = size.y
	var d f32 = size.z

	var left f32 = x - w
	var right f32 = x + w

	var bottom f32 = y - h
	var top f32 = y + h

	var front f32 = z + d
	var back f32 = z - d

	var r f32 = color.x
	var g f32 = color.y
	var b f32 = color.z
	var a f32 = color.w

	var vertices []f32 = g_meshes[mesh].vertices

	r = 1.0
	g = 0.0
	b = 0.0
	vertices = appendV9(vertices, left , bottom, front , r, g, b, a, 0.0, 0.0)
	vertices = appendV9(vertices, right, bottom, front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, left , top   , front , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, left , top   , front , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, right, bottom, front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, right, top   , front , r, g, b, a, 1.0, 1.0)

	r = 0.0
	g = 1.0
	b = 0.0
	vertices = appendV9(vertices, right, bottom, front , r, g, b, a, 0.0, 0.0)
	vertices = appendV9(vertices, right, bottom, back  , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, right, top   , front , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, right, top   , front , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, right, bottom, back  , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, right, top   , back  , r, g, b, a, 1.0, 1.0)

	r = 0.0
	g = 0.0
	b = 1.0
	vertices = appendV9(vertices, right, bottom, back  , r, g, b, a, 0.0, 0.0)
	vertices = appendV9(vertices, left , bottom, back  , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, right, top   , back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, right, top   , back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, left , bottom, back  , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, left , top   , back  , r, g, b, a, 1.0, 1.0)

	r = 1.0
	g = 1.0
	b = 0.0
	vertices = appendV9(vertices, left , bottom, back  , r, g, b, a, 0.0, 0.0)
	vertices = appendV9(vertices, left , bottom, front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, left , top   , back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, left , top   , back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, left , bottom, front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, left , top   , front , r, g, b, a, 1.0, 1.0)

	r = 1.0
	g = 0.0
	b = 1.0
	vertices = appendV9(vertices, left , top   , front , r, g, b, a, 0.0, 0.0)
	vertices = appendV9(vertices, right, top   , front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, left , top   , back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, left , top   , back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, right, top   , front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, right, top   , back  , r, g, b, a, 1.0, 1.0)

	r = 0.0
	g = 1.0
	b = 1.0
	vertices = appendV9(vertices, right, bottom, front , r, g, b, a, 0.0, 0.0)
	vertices = appendV9(vertices, left , bottom, front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, right, bottom, back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, right, bottom, back  , r, g, b, a, 0.0, 1.0)
	vertices = appendV9(vertices, left , bottom, front , r, g, b, a, 1.0, 0.0)
	vertices = appendV9(vertices, left , bottom, back  , r, g, b, a, 1.0, 1.0)

	g_meshes[mesh].vertices = vertices
}

//-----------------------------------------------------------------------------
// MeshAppendGlyph ...
//-----------------------------------------------------------------------------
func MeshAppendGlyph(id MeshId, texture Texture, name str, position mat.v2, scale mat.v2, color mat.v4, glyph i32, debug bool, color0 mat.v4, color1 mat.v4, clip mat.v4, depth f32) {
//	printf("NAME %s\n", name)
	panicIfNot(IsValidMesh(id), "invalid id")
	var index i32 = 0
	var size i32 = 0

	var maxGlyphW i32 = 0;
	var maxGlyphH i32 = 0;
	maxGlyphW, maxGlyphH = gltext.GlyphBounds(name)
	var maxGlyphWidth f32 = i32.f32(maxGlyphW)
	var maxGlyphHeight f32 = i32.f32(maxGlyphH)
	maxGlyphWidth = scale.x * maxGlyphWidth
	maxGlyphHeight = scale.y * maxGlyphHeight

	var textW i32
	var textH i32
	textW, textH = measure_glyph(name, glyph)

	var textWidth f32 = scale.x * i32.f32(textW)
	var textHeight f32 = scale.y * i32.f32(textH)

	var quadX f32 = position.x
	var quadY f32 = position.y - (maxGlyphHeight - textHeight) // - ratio * i32.f32(textH) / gfx_height
	//if (center == true) {
	//	quadX = -1.0 + (2.0 - textWidth / gfx_width) / 2.0 // / gfx_width
	//	quadY =  0.0 - textHeight / (gfx_height * 2.0) // / gfx_height
	//}

	var tw f32 = i32.f32(texture.width)
	var th f32 = i32.f32(texture.height)
	var index i32 = 0
	var dummyIndex i32 = 0
	var debugColor mat.v4

	var rune i32
	var glyphX i32
	var glyphY i32
	var glyphWidth i32
	var glyphHeight i32
	var glyphAdvance i32

	glyphX, glyphY, glyphWidth, glyphHeight, glyphAdvance = gltext.GlyphInfo(name, glyph)
//	printf("RUNE\n")
	var quadAdvance f32 = scale.x * i32.f32(glyphAdvance)// / gfx_width
	var quadWidth f32 = scale.x * i32.f32(glyphWidth)// / gfx_width
	var quadHeight f32 = textHeight //scale.y * i32.f32(glyphHeight)// / gfx_height
	var qu0 f32 = i32.f32(glyphX) / tw
	var qv0 f32 = i32.f32(glyphY) / th

 //   printf("U %f, V %f, GH %f, MGH %f, TH %f\n", qu0, qv0, i32.f32(glyphHeight), maxGlyphHeight, textHeight)
	var qu1 f32 = qu0 + i32.f32(glyphAdvance) / tw
	var qv1 f32 = qv0 + i32.f32(glyphHeight) / th

	if (debug == true) {
		color = color0
		debugColor = color1
		if ((dummyIndex % 2) == 0) {
			color = color1
			debugColor = color0
		}
	}

	//MeshAppendQuad(g_debugMesh, mat.v4_(quadX, quadY, quadAdvance, quadHeight), mat.v4_(qu0, qv0, qu1, qv1), red, clip, depth)
	MeshAppendQuad(id, mat.v4_(quadX, quadY, quadAdvance, quadHeight), mat.v4_(qu0, qv0, qu1, qv1),  color, clip, depth)
	index = index + size
	quadX = quadX + quadAdvance
	dummyIndex = dummyIndex + 1
}

//-----------------------------------------------------------------------------
// MeshAppendText ...
//-----------------------------------------------------------------------------
func MeshAppendText(id MeshId, texture Texture, name str, position mat.v2, scale mat.v2, color mat.v4, text str, debug bool, color0 mat.v4, color1 mat.v4, clip mat.v4, depth f32) {
//	printf("NAME %s\n", name)
//	if (name == "awesomeBold_25") {
	panicIfNot(IsValidMesh(id), "append_text : invalid id")
	var index i32 = 0
	var size i32 = 0

	var maxGlyphW i32 = 0;
	var maxGlyphH i32 = 0;
	maxGlyphW, maxGlyphH = gltext.GlyphBounds(name)
	var maxGlyphWidth f32 = scale.x * i32.f32(maxGlyphW)
	var maxGlyphHeight f32 = scale.y * i32.f32(maxGlyphH)

	var textW i32
	var textH i32
	textW, textH = measure_text(name, text)

	var textWidth f32 = scale.x * i32.f32(textW)
	var textHeight f32 = scale.y * i32.f32(textH)

	var quadX f32 = position.x
	var quadY f32 = position.y - (maxGlyphHeight - textHeight) // - ratio * i32.f32(textH) / gfx_height
	//if (center == true) {
	//	quadX = -1.0 + (2.0 - textWidth / gfx_width) / 2.0 // / gfx_width
	//	quadY =  0.0 - textHeight / (gfx_height * 2.0) // / gfx_height
	//}

	var tw f32 = i32.f32(texture.width)
	var th f32 = i32.f32(texture.height)
	var index i32 = 0
	var dummyIndex i32 = 0
	var debugColor mat.v4

//	printf("TEXT : %s\n", text)

	for (size >= 0) {

		var rune i32
		var glyphX i32
		var glyphY i32
		var glyphWidth i32
		var glyphHeight i32
		var glyphAdvance i32

		rune, size, glyphX, glyphY, glyphWidth, glyphHeight, glyphAdvance = gltext.NextGlyph(name, text, index)
		if (size >= 0) {

//			printf("RUNE\n")
			var quadAdvance f32 = scale.x * i32.f32(glyphAdvance)// / gfx_width
			var quadWidth f32 = scale.x * i32.f32(glyphWidth)// / gfx_width
			var quadHeight f32 = textHeight //scale.y * i32.f32(glyphHeight)// / gfx_height
			var qu0 f32 = i32.f32(glyphX) / tw
			var qv0 f32 = i32.f32(glyphY) / th

  //		  printf("U %f, V %f, GH %f, MGH %f, TH %f\n", qu0, qv0, i32.f32(glyphHeight), maxGlyphHeight, textHeight)
			var qu1 f32 = qu0 + i32.f32(glyphAdvance) / tw
			var qv1 f32 = qv0 + i32.f32(glyphHeight) / th

			panicIfNot(rune >= 0, "invalid rune")
			if (debug == true) {
				color = color0
				debugColor = color1
				if ((dummyIndex % 2) == 0) {
					color = color1
					debugColor = color0
				}
			}

			//MeshAppendQuad(g_debugMesh, mat.v4_(quadX, quadY, quadAdvance, quadHeight), mat.v4_(qu0, qv0, qu1, qv1), red, clip, depth)
			MeshAppendQuad(id, mat.v4_(quadX, quadY, quadAdvance, quadHeight), mat.v4_(qu0, qv0, qu1, qv1),  color, clip, depth)
			index = index + size
			quadX = quadX + quadAdvance
			dummyIndex = dummyIndex + 1
		}// else {
		  //  printf("no rune")
		//}
	}
  //  }
}


