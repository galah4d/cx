package main

import "app"
import "fps"
import "gam"
import "gfx"
import "gl" // ##1 hide gl dependency
import "gui"
import "mat"
import "snd"

// TODO : centre buttons
// TODO : fix black scren when exiting gameScreen
// TODO : fix exitScreen not showing when coming back from gameScreen
// TODO : fix no event data in onEvent callback
// TODO : fix onEvent must return EVENT_UNUSED/EVENT_CONSUMED
// TODO : handle events
// TODO : fix inverted rendering in gameOnRender

// Globals ...
var exit bool

var ry f32 = 0.0

var gameScreen gui.ScreenId
var exitScreen gui.ScreenId

var depthBuffer i32
var groundMesh gfx.MeshId
var cubeMesh gfx.MeshId
var texture gfx.Texture

var deltaTime f64
var rotate []f32
var translate []f32
var world [] f32
var identity [] f32

var audioId snd.AudioId
var voiceId snd.VoiceId

var camera gam.FpsCameraId

var DEBUG_0 []f32

var g_synths []Synth
var g_synthCount i32 = 64

var worldSizeX f32 = 2000.0
var worldSizeZ f32 = 2000.0

var worldCellX i32 = 64
var worldCellZ i32 = 64

// Synth ...
type Synth struct {
	rx f32
	ry f32
	tx f32
	ty f32
	tz f32
	time f32
	frame i32
	animation gui.AnimationId
	batch gfx.BatchId
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onPlayButton(controlIndex i32, action i32) {
	if action == app.KEY_PRESS {
		gui.ScreenShow(gameScreen)
	} else if action != app.KEY_RELEASE && action != app.KEY_REPEAT {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitButton(controlIndex i32, action i32) {
	if action == app.KEY_PRESS {
		gui.ScreenShow(exitScreen)
	} else if action != app.KEY_RELEASE && action != app.KEY_REPEAT {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitDialogNo(controlIndex i32, action i32) {
	var id gui.ControlId = gui.NewControlId(controlIndex)

	if (action == app.KEY_PRESS) {
		printf("NO PRESSED\n")
	} else if (action == app.KEY_RELEASE) {
		printf("NO RELEASED\n")
		gui.hide_modal(exitScreen)
		printf("HERE\n")
	} else if (action == app.KEY_REPEAT) {
		printf("NO REPEAT\n")
	} else {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitDialogYes(controlIndex i32, action i32) {
	var id gui.ControlId = gui.NewControlId(controlIndex)

	if (action == app.KEY_PRESS) {
		printf("YES PRESSED\n")
	} else if (action == app.KEY_RELEASE) {
		printf("YES RELEASED\n")
		gui.hide_modal(exitScreen)
		exit = true
	} else if (action == app.KEY_REPEAT) {
		printf("YES REPEAT\n")
	} else {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func skycoinOnUpdate(controlIndex i32, action i32) {
	if snd.VoiceState(voiceId) == snd.VOICE_STOPPED {
		snd.VoicePlay(voiceId)
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnEvent(controlIndex i32, action i32) {
	var id gui.ControlId = gui.NewControlId(controlIndex)
	gam.FpsCameraProcess(camera, &gui.CurrentEvent)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnUpdate(controlIndex i32, action i32) {
	gam.FpsCameraUpdate(camera, deltaTime)
	gam.FpsCameraApply(camera, &gfx.State)

	var dt f32 = f64.f32(deltaTime)

	ry = ry + f64.f32(deltaTime)

	rotate = resize(rotate, 0)
	rotate = mat.RotationY(rotate, ry)

	translate = resize(translate, 0)
	translate = mat.Translate(translate, 0.0, 0.0, 0.0)

	world = resize(world, 0)
	world = mat.Multiply(world, rotate, translate)

	gfx.MeshBegin(cubeMesh)
	gfx.MeshAppendCube(cubeMesh,
		mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(10.0, 10.0, 10.0),
		mat.v4_(1.0, 1.0, 1.0, 1.0))
	gfx.MeshEnd(cubeMesh)

	gfx.MeshBegin(groundMesh)
	gfx.MeshAppendPlane(groundMesh,
		mat.v3_(-worldSizeX / 2.0, -10.0, -worldSizeZ / 2.0),
		mat.v3_(worldSizeX, 0.0, 0.0),
		mat.v3_(0.0, 0.0, worldSizeZ),
		16, 16,
		mat.v4_(0.0, 0.0, 10.0, 10.0),
		mat.v4_(1.0, 1.0, 1.0, 1.0))
	gfx.MeshEnd(groundMesh)

	for i := 0; i < g_synthCount; i++ {
		var ty f32 = g_synths[i].ty
		var frame i32 = g_synths[i].frame
		var frameCount i32 = 0
		var animation AnimationId
		if ty <= 0.0 {
			ty = 500.0 + f32.rand() * 100.0
			animation = gui.g_dumpcxAnim
			frameCount = gui.AnimationFrameCount(animation)
			frame = 0//i32.rand(0, frameCount)
			g_synths[i].animation = animation
			g_synths[i].tx = i32.f32(i32.rand(0, worldCellX)) * worldSizeX / i32.f32(worldCellX) - worldSizeX / 2.0
			g_synths[i].tz = i32.f32(i32.rand(0, worldCellZ)) * worldSizeZ / i32.f32(worldCellZ) - worldSizeZ / 2.0
		} else {
			animation = g_synths[i].animation
			frameCount = gui.AnimationFrameCount(animation)
			//frame++
			if frame >= frameCount {
				frame = 0
			}
			ty = ty - 20.0 * dt + f32.rand() * 10.0 * dt
		}

		//var texture gfx.Texture = gui.AnimationGetFrame(animation, frame)
		//var batch gfx.BatchId = gfx.GetBatch(gfx.g_fxPerspectiveTexture, texture, 0, false, 4096 * 30)
		//printf("GET_BATCH %d\n", batch.batch)
		//g_synths[i].batch = batch
		g_synths[i].frame = frame
		g_synths[i].ty = ty
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnRender(controlIndex i32, action i32) {
	var id gui.ControlId = gui.NewControlId(controlIndex)
	gfx.DisableBlending()
	gfx.DepthState(true, gl.LESS, true)
	gfx.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, mat.v4_(0.3, 0.5, 0.6, 1.0), 1.0D, 0)
	gfx.EffectUse(gfx.g_fxPerspectiveTexture)
	gfx.EffectAssignMatrix4(gfx.g_fxPerspectiveTexture, 1, gam.FpsCameraGetView(camera), false)
	gfx.EffectAssignMatrix4(gfx.g_fxPerspectiveTexture, 2, gam.FpsCameraGetProjection(camera), false)

	// cubeMesh
	gfx.EffectAssignTexture(gfx.g_fxPerspectiveTexture, 0, texture.name)
	gfx.TextureWrap(gl.REPEAT, gl.REPEAT, gl.REPEAT)
	gfx.TextureFilter(gl.LINEAR, gl.LINEAR)
	gfx.EffectAssignMatrix4(gfx.g_fxPerspectiveTexture, 0, world, false)
	// ISSUE : can't use gfx.State.View : error: 13_camera.cx:154 function 'EffectAssignMatrix4' expected input argument of type '[]f32'; 'f32' was provided
	gfx.MeshRender(cubeMesh)

	// groundMesh
	gfx.EffectAssignTexture(gfx.g_fxPerspectiveTexture, 0, texture.name)
	gfx.TextureWrap(gl.REPEAT, gl.REPEAT, gl.REPEAT)
	gfx.TextureFilter(gl.LINEAR, gl.LINEAR)
	gfx.EffectAssignMatrix4(gfx.g_fxPerspectiveTexture, 0, identity, false)
	DEBUG_0 = resize(DEBUG_0, 4)
	DEBUG_0[0] = 0.0
	DEBUG_0[1] = 0.0
	DEBUG_0[2] = 0.0
	DEBUG_0[3] = 0.0
	gfx.EffectAssignVector4(gfx.g_fxPerspectiveTexture, 3, DEBUG_0)
	gfx.MeshRender(groundMesh)

	//printf("---------------------------------------------- BEGIN\n")
	for i := 0; i < g_synthCount; i++ {
		var frame i32 = g_synths[i].frame
		var animation gui.AnimationId = g_synths[i].animation
		var t gfx.Texture = gui.AnimationGetFrame(animation, frame) // ISSUE : can't be named texture : silently clash with global variable
		var batch gfx.BatchId = gfx.GetBatch(gfx.g_fxPerspectiveTexture, t, 0, false, 4096 * 30)
		//printf("GET_BATCH %d, FRAME %d\n", batch.batch, frame)
		g_synths[i].batch = batch
	}
	gfx.BeginBatches()

	for i = 0; i < g_synthCount; i++ { // ISSUE : can't use i := 0, Error: 14_synth.cx:250 'i' redeclared
		var batch gfx.BatchId = g_synths[i].batch
		var mesh gfx.MeshId = gfx.BatchGetMesh(batch)
		//printf("BATCH %d, MESH %d, COUNT %d\n", batch.batch, mesh.mesh, len(gfx.g_meshes[mesh.mesh].vertices))
		var tx f32 = g_synths[i].tx
		var ty f32 = g_synths[i].ty
		var tz f32 = g_synths[i].tz
		gfx.MeshAppendCube(mesh,
			mat.v3_(tx, ty, tz),
			mat.v3_(20.0, 20.0, 20.0),
			mat.v4_(1.0, 1.0, 1.0, 1.0))
	}
	gfx.EndBatches()
	gfx.RenderBatches(false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func main()() {
	var o app.Options
	o.width = 800
	o.height = 600
	o.fps = 60
	o.Parse()

	var appName str
	appName = "Batch Tutorial"

	var f fps.Framerate
	f.Init(i32.f64(o.fps))

	var prfSwap fps.ProfileId = fps.CreateProfile("swap")
	var prfFrame fps.ProfileId = fps.CreateProfile("frame")
	var prfUpdate fps.ProfileId = fps.CreateProfile("update")
	var prfRender fps.ProfileId = fps.CreateProfile("render")

	var a app.Application
	a.Init(o, appName, "mainWindow", 2, 1)
	gfx.Init(o.width, o.height, o.dataDir)
	gui.Init(&a, o.width, o.height, o.dataDir)
	snd.Init(64, 64)

	texture = gfx.TextureCreate(sprintf("%s/textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", o.dataDir),
		gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0, true)

	var width f32 = gfx.gfx_viewportSize.x
	var height f32 = gfx.gfx_viewportSize.y

	camera = gam.FpsCameraCreate(0.1, 10000.0, 0.5, width, height) // ISSUE : gfx.gfx_viewportSize.y / gfx.gfx_viewportSize.x)

	identity = mat.Identity(identity)

	depthBuffer = gfx.create_depth_buffer(gl.DEPTH_COMPONENT, o.width, o.height)

	cubeMesh = gfx.MeshLock(gl.TRIANGLES, gfx.g_vertexColorAttributes, 36 * 1024)
	groundMesh = gfx.MeshLock(gl.TRIANGLES, gfx.g_vertexColorAttributes, 6 * 64 * 64)

	g_synths = resize(g_synths, g_synthCount)

	// exitScreen
	exitScreen  = gui.ScreenCreate("exitScreen")
	gui.ControlSetSkin(exitScreen.base, gui.g_modalSkin)
	gui.ControlSetBounds(exitScreen.base, gfx.gfx_viewportBounds)
	gui.ScreenSetDuration(exitScreen, -2.0D)
	gui.ScreenSetModal(exitScreen, true)

	{
		var exitWindow gui.window_id = gui.window_create("exitWindow")
		gui.ControlAddChild(exitScreen.base, exitWindow.base)
		gui.ControlSetSkin(exitWindow.base, gui.g_windowSkin)
		gui.ControlSetAutosize(exitWindow.base, gui.AUTOSIZE)
		gui.ControlSetAlign(exitWindow.base, gui.ALIGN_CENTER)
		gui.window_set_caption(exitWindow, "cxfx")
		gui.window_add_button(exitWindow, "no", "No", "main", "onExitDialogNo")
		gui.window_add_button(exitWindow, "yes", "Yes", "main", "onExitDialogYes")

		{
			var exitLabel gui.LabelId = gui.LabelCreate("exitLabel")
			gui.window_set_containee(exitWindow, exitLabel.base)
			gui.ControlSetDock(exitLabel.base, gui.DOCK_FILL)
			gui.ControlSetAutosize(exitLabel.base, gui.AUTOSIZE)
			gui.LabelSetFont(exitLabel, gui.g_regularFont)
			gui.LabelSetText(exitLabel, "Do you want to quit ?")
			gui.LabelSetSize(exitLabel, gui.g_fontSizeText)
			gui.LabelSetColor(exitLabel, gui.g_white)
			gui.LabelSetAlign(exitLabel, gui.ALIGN_CENTER)
		}
	}

	// mainScreen
	var mainScreen gui.ScreenId = gui.ScreenCreate("mainScreen")
	gui.ControlSetSkin(mainScreen.base, gui.g_blackSkin)
	gui.ControlSetSize(mainScreen.base, gfx.gfx_viewportSize)
	gui.ControlSetPadding(mainScreen.base, mat.v4_(200.0, 150.0, 200.0, 150.0))
	gui.ScreenSetDuration(mainScreen, -2.0D)
	gui.ScreenSetOnExit(mainScreen, exitScreen)
	{
		var playButton gui.LabelId = gui.LabelCreate("playButton")
		gui.ControlAddChild(mainScreen.base, playButton.base)
		gui.ControlSetSkin(playButton.base, gui.g_blueSkin)
		gui.ControlSetDock(playButton.base, gui.DOCK_TOP)
		gui.ControlSetFocusable(playButton.base, 1)
		gui.ControlSetPadding(playButton.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
		gui.ControlSetAutosize(playButton.base, gui.AUTOSIZE_Y)
		gui.LabelSetFont(playButton, gui.g_boldFont)
		gui.LabelSetText(playButton, "Play")
		gui.LabelSetOnState(playButton, "main", "onPlayButton")
		gui.LabelSetSize(playButton, gui.g_fontSizeButton)
		gui.LabelSetColor(playButton, gui.g_white)
		gui.LabelSetAlign(playButton, gui.ALIGN_CENTER)

		var exitButton gui.LabelId = gui.LabelCreate("exitButton")
		gui.ControlAddChild(mainScreen.base, exitButton.base)
		gui.ControlSetSkin(exitButton.base, gui.g_blueSkin)
		gui.ControlSetDock(exitButton.base, gui.DOCK_TOP)
		gui.ControlSetFocusable(exitButton.base, 1)
		gui.ControlSetPadding(exitButton.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
		gui.ControlSetAutosize(exitButton.base, gui.AUTOSIZE_Y)
		gui.LabelSetFont(exitButton, gui.g_boldFont)
		gui.LabelSetText(exitButton, "Exit")
		gui.LabelSetOnState(exitButton, "main", "onExitButton")
		gui.LabelSetSize(exitButton, gui.g_fontSizeButton)
		gui.LabelSetColor(exitButton, gui.g_white)
		gui.LabelSetAlign(exitButton, gui.ALIGN_CENTER)
	}

	// gameScreen
	gameScreen = gui.ScreenCreate("gameScreen")
	gui.ControlSetSkin(gameScreen.base, gui.g_blackSkin)
	gui.ControlSetSize(gameScreen.base, gfx.gfx_viewportSize)
	gui.ScreenSetDuration(gameScreen, -2.0D)
	gui.ScreenSetOnExit(gameScreen, mainScreen)
	gui.ScreenSetOnEvent(gameScreen, "main", "gameOnEvent")
	gui.ScreenSetOnUpdate(gameScreen, "main", "gameOnUpdate")
	gui.ScreenSetOnRender(gameScreen, "main", "gameOnRender")


	// titleScreen
	var titleScreen gui.ScreenId = gui.ScreenCreate("titleScreen")
	gui.ControlSetSkin(titleScreen.base, gui.g_blackSkin)
	gui.ControlSetBounds(titleScreen.base, gfx.gfx_viewportBounds)
	gui.ScreenSetDuration(titleScreen, 2.0D)
	gui.ScreenSetOnNext(titleScreen, mainScreen)
	{
		var label gui.LabelId= gui.LabelCreate("titleLabel")
		gui.ControlAddChild(titleScreen.base, label.base)
		gui.ControlSetBounds(label.base, mat.v4_(0.0, 0.0, gfx.gfx_width, gfx.gfx_height))
		gui.ControlSetAlign(label.base, gui.ALIGN_CENTER)
		gui.LabelSetFont(label, gui.g_boldFont)
		gui.LabelSetText(label, appName)
		gui.LabelSetSize(label, gui.g_fontSizeTitle)
		gui.LabelSetAlign(label, gui.ALIGN_CENTER)
		gui.LabelSetColor(label, gui.g_gold)
	}

	// skycoinScreen
	var skycoinScreen gui.ScreenId = gui.ScreenCreate("skycoinScreen")
	gui.ControlSetSkin(skycoinScreen.base, gui.g_blackSkin)
	gui.ControlSetBounds(skycoinScreen.base, gfx.gfx_viewportBounds)
	gui.ScreenSetDuration(skycoinScreen, 2.0D)
	gui.ScreenSetOnNext(skycoinScreen, titleScreen)
	gui.ScreenSetOnUpdate(skycoinScreen, "main", "skycoinOnUpdate")
	{
		var picture PictureId = gui.PictureCreate("skycoinPicture")
		gui.ControlAddChild(skycoinScreen.base, picture.base)
		gui.ControlSetBounds(picture.base, mat.v4_(0.0, 0.0, gfx.gfx_width / 2.0, gfx.gfx_height / 2.0))
		gui.ControlSetAlign(picture.base, gui.ALIGN_CENTER)
		gui.ControlSetAutoscale(picture.base, gui.AUTOSCALE)
		gui.PictureSetAlign(picture, gui.ALIGN_CENTER)
		gui.PictureSetAnimation(picture, gui.g_skycoinAnim)
	}

	// bootScreen
	var bootScreen gui.ScreenId = gui.ScreenCreate("bootScreen")
	gui.ControlSetSkin(bootScreen.base, gui.g_bootSkin)
	gui.ControlSetSize(bootScreen.base, gfx.gfx_viewportSize)
	gui.ScreenSetDuration(bootScreen, 2.0D)
	gui.ScreenSetOnNext(bootScreen, skycoinScreen)

	gui.ScreenShow(bootScreen)

	var audioId snd.AudioId = snd.AudioCreate(sprintf("%s/audios/skycoin_baby.wav", o.dataDir)) // TODO : find good audio file
	var voiceId snd.VoiceId = snd.VoiceCreate(audioId)

	for app.Running(&a) { // ISSUE : can't use member function
		f.BeginUpdate(2.0D)
		fps.StartProfile(prfSwap)
		{
			a.BeginFrame()
			fps.StartProfile(prfFrame)
			{
				// Update ...
				fps.StartProfile(prfUpdate)
				if exit {
					a.Exit()
				}
				deltaTime = f.deltaTime
				snd.Update()
				gui.update(f.deltaTime)
				gui.resize()
				fps.StopProfile(prfUpdate)

				// Render ...
				fps.StartProfile(prfRender)
				gui.render()
				fps.StopProfile(prfRender)
			}
			fps.StopProfile(prfFrame)
			a.EndFrame()
		}
		fps.StopProfile(prfSwap)
		f.EndUpdate()
	}

	snd.Destroy()

	gfx.MeshUnlock(cubeMesh)
	gfx.MeshUnlock(groundMesh)

	gfx.Free()
}
